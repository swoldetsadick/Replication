---
title: "On the Evolution of Firm Size Distributions"
author: "Woldetsadick Selam Getachew"
date: "Monday, September 15, 2014"
output: html_document
---
<h4,align="left>Replication of findings [A,Paolo & A,Generale (2008)](http://www.jstor.org/discover/10.2307/29729977?uid=3737864&uid=2&uid=4&sid=21104166174021)<sup>1</sup></h4>
<br>
```{r set-options, cache = TRUE}
```
```{r,echo = FALSE, results = 'hide', cache = TRUE}
old.loc <- Sys.getlocale("LC_TIME")
Sys.setlocale(category = "LC_TIME", locale="English")
time <- format(Sys.time(),"%a, %b %d %Y, %X")
version <- R.Version()
varsion <- version[[13]]
old.loc <- Sys.getlocale("LC_TIME")
```

<h1 align="center">Motivation</h1>
<hr width="100%"  noshade size=4>

This work is an attempt at a **replication** of Angelini Paolo and Andrea Generale's 2008 article entitled *On the Evolution of Firm Size Distributions* and published in the American Economic Review<sup>1</sup>.Econometric study for the original article was implemented in SAS statistical analysis software, in this replication R a different statistical analysis software will be used.The goal of this replication work is to indeed replicate findings of the original authors of the article, and extend their results.<br>
The raw data and code books pdf can be found [here](http://www.aeaweb.org/aer/data/mar08/20050397_data.zip) for downloading.<br>
The following analysis was made using the `r time` version of the raw data, and `r varsion` version of R combined with RStudio Desktop v0.98.1056 front.<br> 
<br>
<br>

<h1 align="center">Introduction</h1>
<hr width="100%" noshade size=4>
hereinafter the study

<br>
<br>

<h1 align="center">Loading and pre-processing raw data</h1>
<hr width=100% noshade size=4>
<h4 align="left"> A - Loading the Data</h4>
This chuck of R code uses `dowloader` library to download directly data from the url specified in *url* symbol. The data thus obtained is unzipped using `unzip` function and stored in *ori* symbol. After data is coerced into a matrix aspect and  assigned *mat* symbol, first column - second line of said matrix, corresponding to raw data, is loaded using `read.dta` function of `foreign` library.The raw is therefore named *data* in R.<br>
Also `shell.exec` function is used to open the code book for user automatically. Make sure you have a pdf reader installed.
```{r, cache = TRUE}
library(foreign)
library(downloader)
setwd("C:/Users/anton_000/Documents/Downloads/Desktop/Replication")
url <- "http://www.aeaweb.org/aer/data/mar08/20050397_data.zip"
download(url,"datasur.dat", mode="wb")
ori <- unzip("datasur.dat")
mat <- matrix(ori)
data <- read.dta(mat[2,1])
shell.exec(file.path(getwd(), "readme.pdf"))
```
<br>
<h4 align="left"> B - Pre-processing the Data</h4>
First a quick look at the names of columns in the data set charged in R environment to compare it with **readme.pdf** listed variables, and also the classes of all variables to match with information in readme file.
```{r, cache = TRUE}
names <- names(data) #storing column names in "names" vector
classes <- rep(0, times=ncol(data)) # creating vector to store classes of data column
for(i in 1:ncol(data)) {classes[i] <- class(data[,i])} # for each column in data finding class storing it in vector "classes" 
names #displaying names
classes# displaying classes
```
<br>As can be seen above although all variables listed in the readme file are present in our data set, all of them seem to have a numeric class in R. However, variable *anno* should be treated as a variable of **Date class** and variables *ACO*, *AIM*, *SALES*, *sales*, *UTIL*, *UTILN*, *OF*, *IMIM* and *IMTE* should have **class numeric**, *indentif* **class factor**, while *the rest* should have **class integer**.<br>
In the following chunk of code does exactly that.
```{r, cache = TRUE}
data$anno <- as.Date(paste(as.character(data$anno),paste("01","01",sep="-"),sep="-"),"%Y-%m-%d") # changing class for anno variable to date
data$identif <- as.factor(data$identif) # indentif number is treated as factor
classes <- rep(0, times=ncol(data)) # creating vector to store classes of data column
for(i in 1:ncol(data)) {classes[i] <- class(data[,i])} # for each column in data finding class storing it in vector "classes" 
classes # displaying classes
```
It can be seen above that classes of variables in the data set are made to match expectations in view of code book. Also note that month and day of observations have been set to default 01-01 because they are unavailable in raw data. <br>
Now that this pre-processing of data is finished, the process of tidying the data and making it "regression" friendly can start. 
<br>
<br>
<h1 align="center">Generating estimation data sets</h1>
<h4 align="center">Transcribing data set.do and obtaining open9201.dta, closed9201.dta and tempstime_1.dta</h3>
<hr width="100%" noshade size=4>

<h4 align="left"> A - Main Data Sets</h4>
The code chunks in the following sub-part of this document loads the Mediocredito Survey & Balance Sheet data containing information for each individual firms for each four years separately, generates and saves relevant variables used in the original paper.<br>
Data from each different years need slightly adjusted code to process them compared to one another.<br>

<h6 align="left">1 - Creating intermediary data set csur92</h6>
Generating data for firms observed in 1992, each have unique identifier that they keep over the years.<br>
Here only observations current to 1992 (ranging 1989-1991) for firms in data set are selected and saved in csur92 data set. Additionally these firms should have a correct observation for number of employees the 3 years before (1989-1991) in order to be able to calculate labor growth.<br>
```{r, cache=TRUE}
csur92 <- subset(data,ind92==1 & dip91!="." & dip91>0)     
```
Now that only observations only from 1992 are chosen via indicator ind==92, relevant variables can be are created.<br>
In the code chunk below the log of size of sales (expressed in thousand euros) variable **lsize** is created. This will serve as proxy for size of firm.
```{r, cache=TRUE}
csur92$lsize <- ifelse(csur92$sales<= 0 , NA, log(csur92$sales))    
```
In the next chunk of code, dummies establishing baseline definition of rationing, or financial constraint, are constructed out of *d17_1*, *d17_2*, *d17_3* or *d17_4* variables.These variables are coded answers for questions of whether or not a firm encountered difficulties in financing their last investment project due to insufficient cash flow, lack of collateral, insufficient long-term finance or high cost of debt respectively. In this case multiple answers were allowed with an intensity ranking from 1 to 3, missing values being coded as equal to 9.<br>
As indicated in p.427 of the original article, "In the 1992 survey, we define a firm as constrained if at least one question of the first four causes was given the highest importance." Hence the new rationing variable **razd** takes a value of 1, indicating a financially constrained firm, if above conditions are met, NA if observations for all four original variables are equal to 9, or missing, 0 in any other case.<br>
A duplicated of **razd** variable therefore created is stored under the label **raz92d**.
```{r, cache=TRUE}
csur92$razd <- as.factor(ifelse(csur92$d17_1==3|csur92$d17_2==3|csur92$d17_3==3|csur92$d17_4==3,1,ifelse(csur92$d17_1==9 &csur92$d17_2==9 & csur92$d17_3==9 & csur92$d17_4==9,NA,0)))
csur92$raz92d <- csur92$razd    
```
In the next chunk of code, Merger and Acquisition indicators are created. A new variable **duacq** is coded as being equal to 1 if the firm was party to mergers or acquisition, and takes 0 in cases of both missing value or if the firm not being party to m&a. This new variable is a version of ACQUI variable in original data set.<br>
A new variable **dusco** is created as being equal to 1 if the firm was created through a spin off, and takes 0 in cases of both missing value or if the firm was not created through a spin off.This new variable is a version of SCORPO variable in original data set.<br>
```{r, cache = TRUE}
csur92$duacq <- ifelse(is.na(csur92$acqui),0,ifelse(csur92$acqui==1,1,0))   
csur92$dusco<- ifelse(is.na(csur92$scorpo),0,ifelse(csur92$scorpo==1,1,0))
```
In the next code chunk, sectoral dummies according to "Keith Pavitt" classification are given. In the original data the information is coded in PAV variable which takes values of 1 to 4 if firm belongs to traditional sector, or is scale intensive, or is a specialized supplier, or a high technology respectively. However in the present data set, this variable is separated into four, each specifically answering to one question. **dupav1** answers if firm is in traditional sector taking value 1 or not taking value 0. **dupav2** answers if firm is scale intensive taking value 1 or not taking value 0. **dupav3** answers if firm is a specialized supplier taking value 1 or not taking value 0. **dupav4** answers if firm is in high-technology taking value 1 or not taking value 0.
```{r, cache = TRUE}
csur92$dupav1 <- ifelse(csur92$pav == 1, 1, 0)
csur92$dupav2 <- ifelse(csur92$pav == 2, 1, 0)   
csur92$dupav3 <- ifelse(csur92$pav == 3, 1, 0)
csur92$dupav4 <- ifelse(csur92$pav == 4, 1, 0) 
```
In the next code chunk, balance sheet variables are defined. Variable **roa** represents the return on assets, as a ratio of earnings before financial expense, coded as variable UTIL in the original data set, over the sum of current & net fixed assets, coded as variable ACO and AIM respectively in the original data set.Variable **ofut** represents a ratio of financial expenses represented by variable of in original data set, over operating profits as sum of financial expenses themselves and earnings before taxes and extraordinary items. It defines in essence the share of financial expenses in operating profits.<br>
Variable **quoimm** represents the share of tangible assets, coded by variable IMTE in the original data set, over total assets defined as a sum between current and net fixed assets. Moreover, a new **lsales** variables which represents log of sales number is introduced. All balance sheet variables are expressed in thousands euros.
```{r, cache = TRUE}
csur92$roa <- (csur92$util/(csur92$aco+csur92$aim))
csur92$ofut <- (csur92$of/(csur92$of+csur92$utiln))   
csur92$quoimm <- (csur92$imte/(csur92$aco+csur92$aim))
csur92$lsales <- ifelse(csur92$sales<= 0 , NA, log(csur92$sales))
```
The next code chunks generate dummies for low coverage or low collateral. The rationale behind it can be explained as follows. If the ratio of financial expenses over operating profits, as represented by variable **ofut**, is high, one can conclude that the firm is confronted with high cost of debt and has hence a low coverage. In the same manner, if the share of tangible assets over total asset, as represented by variable **quoimm** is low, one can conclude that the firm in question is confronted to insufficient collateral.
Then we create variables **pofut** and **pquoimm** that represent 75<sup>th</sup> by year of the ratio financial expenses over operating profits, and 25<sup>th</sup> percentile by year of the share of tangible assets over total assets.<br>
At last, variable **duofut** is an indicator of low coverage, taking value of 1 if value of financial expenses over operating profits for that year for that firm is in the 25%  higher values indicating low coverage, 0 if not. In the same manner, variable **dimm** indicates low collateral, taking a value of 1 if the share of tangible assets over total assets for that firm in that year is in the lowest 25%, indicating low collateral, and 0 if not. At last data is ordered by the *identif* variable.
```{r, cache = TRUE}
library(plyr)
common <- data.frame(tapply(csur92$ofut, csur92$anno, quantile, probs=.75, na.rm = TRUE))
a <- data.frame(rep(NA, times = (12 - nrow(common))))
names(common)[1] <- "common"
names(a)[1] <- "common"
common <- data.frame(rbind(common,a))
csur92$pofut <- ifelse(csur92$anno=="1989-01-01",common[1,1],ifelse(csur92$anno=="1990-01-01",common[2,1],ifelse(csur92$anno=="1991-01-01",common[3,1],ifelse(csur92$anno=="1992-01-01",common[4,1],ifelse(csur92$anno=="1993-01-01",common[5,1],ifelse(csur92$anno=="1994-01-01",common[6,1],ifelse(csur92$anno=="1995-01-01",common[7,1],ifelse(csur92$anno=="1996-01-01",common[8,1],ifelse(csur92$anno=="1997-01-01",common[9,1],ifelse(csur92$anno=="1998-01-01",common[10,1],ifelse(csur92$anno=="1999-01-01",common[11,1],common[12,1])))))))))))

common <- data.frame(tapply(csur92$quoimm, csur92$anno, quantile, probs=.25, na.rm = TRUE))
b <- data.frame(rep(NA, times = (12 - nrow(common))))
names(common)[1] <- "common"
names(b)[1] <- "common"     
common <- data.frame(rbind(common, b))
csur92$duofut <- as.factor(ifelse(round(csur92$ofut, digits = 4) > round(csur92$pofut, digits = 4) & round(csur92$ofut, digits = 4) != ".",1,ifelse(round(csur92$ofut, digits = 4)==".",".",0)))

csur92$pquoimm <- ifelse(csur92$anno=="1989-01-01",common[1,1],ifelse(csur92$anno=="1990-01-01",common[2,1],ifelse(csur92$anno=="1991-01-01",common[3,1],ifelse(csur92$anno=="1992-01-01",common[4,1],ifelse(csur92$anno=="1993-01-01",common[5,1],ifelse(csur92$anno=="1994-01-01",common[6,1],ifelse(csur92$anno=="1995-01-01",common[7,1],ifelse(csur92$anno=="1996-01-01",common[8,1],ifelse(csur92$anno=="1997-01-01",common[9,1],ifelse(csur92$anno=="1998-01-01",common[10,1],ifelse(csur92$anno=="1999-01-01",common[11,1],common[12,1])))))))))))
csur92$dimm <- as.factor(ifelse(((round(csur92$quoimm, digits = 4) < round(csur92$pquoimm, digits = 4)) & (round(csur92$pquoimm, digits = 4) != ".")), 1, ifelse(round(csur92$quoimm, digits = 4)==".", ".", 0)))

csur92[grep("acqui",colnames(csur92))]=NULL
csur92[grep("scorpo",colnames(csur92))]=NULL
csur92[grep("^pav$",colnames(csur92))]=NULL
csur92 <- csur92[order(csur92$identif),]
a <- csur92[8184, 58]     
```
It is to be noticed here that generating quantiles with R and STATA gives slightly different values for **pquoimm** & **pofut**. The magnitude in differences is about 10<sup>-4</sup>. However this means that for one observation in the csur92 data set, **identif**=11636 for **anno**=1991 the resulting **duofut** variable has a value of `r a` in R , while this value is 0 for STATA.<br>
Observe that in generating **duofut** & **dimm** variables, variables used to compute them out from were rounded to 4 digits. It is the number of digits that offers the minimum number of differences in csur92 between data generated with R and STATA.<br><br>
<table style="width:50%" border="9" align="center"> <caption>Differences Between R & STATA Generated csur92 Data Set</caption> <tr> <td>identif</td><td>anno</td><td>R</td><td>STATA</td></tr> <tr> <td>11636</td><td>1991</td><td>duofut = 1</td><td>duofut = 0</td></tr></table><br>
<h6 align="left">2 - Creating intermediary data set csur95</h6>
The description of the methods of creation of the different variables described above for <u>csur92</u> data set holds for <u>csur95</u> data set, except in two minor differences. The first in the building of **razd** variable present in the data set above, and the second in the introduction of a new variable **dugr**.<br>
Here only observations current to 1995 (ranging 1991-1994) for firms in data set are selected and saved in csur95 data set. Additionally these firms should have a correct observation for number of employees the 3 years before (1991-1994) in order to be able to calculate labor growth.<br>
```{r, cache = TRUE}
csur95 <- subset(data,ind95==1 & dip94!="." & dip94>0)
#Size as Proxied by Total Sales;     
csur95$lsize <- ifelse(csur95$sales<= 0 , NA, log(csur95$sales))
```
The baseline definition of financial constraints in the 1995 survey is defined somehow different compared to 1992 survey. The construction of **razd** variable indicating financial constraint depends on variables *NONOTTEN* and *AVREBACC* in original data set. These two variables code yes or no answers (1 being yes and 0 No) to questions "Did in 1994 the firm wanted more credit, asked for it and was turned down by the bank ?" and "Was in 1994 the firm ready to pay higher loan rates or pledge more collateral to obtain more credit ?" respectively.<br>
If the first question was answered with a yes, then the firm is considered as financially constrained and variable **razd** will be equal to 1. If answers to both questions were missing then data on financial constraint is considered as missing. In any other case, firm is considered financially not constrained, giving a value of NA and 0 respectively.<br>
A copy of **razd** variable is made in variable **raz95d**.
```{r, cache = TRUE}
#Dummy Rationing Baseline def.;     
csur95$razd <- ifelse(csur95$nonotten == "."|is.na(csur95$nonotten) == TRUE, 0, ifelse(csur95$nonotten==1, 1, 0))
csur95$raz95d <- csur95$razd
a <- ifelse(is.na(csur95$nonotten)==TRUE, 0, ifelse(csur95$nonotten == 0, 20, 10))
b <- ifelse(is.na(csur95$avrebacc)==TRUE, 0, ifelse(csur95$avrebacc == 0, 2, 1))
c <- a + b
csur95$razd <- ifelse(c==0, NA, ifelse(c==10|c==11|c==12, 1, 0))
```
The M&A dummies are basically defined exactly as in above section.
```{r, cache = TRUE}
#Dummies M&A's;    
csur95$duacq <- ifelse(is.na(csur95$acqui),0,ifelse(csur95$acqui==1,1,0))
csur95$dusco<- ifelse(is.na(csur95$scorpo),0,ifelse(csur95$scorpo==1,1,0))
```
Here a new variable **dugr** is introduced based on *isgru* variable of original data set. The latter has a value of 1, if the firm in question is part of an industrial group, and 0 if not with possible NA values. However, **dugr** is constructed as equal to 1 if the firm is part of an industrial group, and 0 in any other situations.
```{r, cache = TRUE}
#Dummy Industrial Group   
csur95$durg <- ifelse(is.na(csur95$isgru),0,ifelse(csur95$isgru==1,1,0))
```
The following steps are defined exactly as in above section.
```{r, cache = TRUE}
#4 Pavitt Sectoral Dummies;
csur95$dupav1 <- ifelse(csur95$pav==1,1,0)
csur95$dupav2 <- ifelse(csur95$pav==2,1,0)
csur95$dupav3 <- ifelse(csur95$pav==3,1,0)
csur95$dupav4 <- ifelse(csur95$pav==4,1,0)
  
#Defining Balance-Sheet Variables
#Return on Assets
csur95$roa <- csur95$util/(csur95$aco + csur95$aim)
#Financial Expenses/Operating Profits
csur95$ofut <- ifelse(csur95$of/(csur95$of + csur95$utiln) == Inf, NA , csur95$of/(csur95$of + csur95$utiln))
#Share of Tangible Assets over Total Assets
csur95$quoimm <- csur95$imte/(csur95$aco + csur95$aim)
#Log of Sales
csur95$lsales <- ifelse(csur95$sales<= 0 , NA, log(csur95$sales))

#Generating Percentiles for the Dummies Low Coverage - Low Collateral
library(plyr)
common <- data.frame(tapply(csur95$ofut, csur95$anno, quantile, probs=.75, na.rm = TRUE))
a <- data.frame(rep(NA, times = 3))
b <- data.frame(rep(NA, times = (9 - nrow(common))))
names(common)[1] <- "common"
names(a)[1] <- "common"
names(b)[1] <- "common"
common <- data.frame(rbind(a, common, b))
csur95$pofut <- ifelse(csur95$anno=="1989-01-01",common[1,1],ifelse(csur95$anno=="1990-01-01",common[2,1],ifelse(csur95$anno=="1991-01-01",common[3,1],ifelse(csur95$anno=="1992-01-01",common[4,1],ifelse(csur95$anno=="1993-01-01",common[5,1],ifelse(csur95$anno=="1994-01-01",common[6,1],ifelse(csur95$anno=="1995-01-01",common[7,1],ifelse(csur95$anno=="1996-01-01",common[8,1],ifelse(csur95$anno=="1997-01-01",common[9,1],ifelse(csur95$anno=="1998-01-01",common[10,1],ifelse(csur95$anno=="1999-01-01",common[11,1],common[12,1])))))))))))

common <- data.frame(tapply(csur95$quoimm, csur95$anno, quantile, probs=.25, na.rm = TRUE))
a <- data.frame(rep(NA, times = 3))
b <- data.frame(rep(NA, times = (9 - nrow(common))))
names(common)[1] <- "common"
names(a)[1] <- "common"
names(b)[1] <- "common"
common <- data.frame(rbind(a, common, b))
csur95$duofut <- as.factor(ifelse(round(csur95$ofut, digits = 5) > round(csur95$pofut, digits = 5) & round(csur95$ofut, digits = 5) != ".",1,ifelse(round(csur95$ofut, digits = 5)==".",".",0)))

csur95$pquoimm <- ifelse(csur95$anno=="1989-01-01",common[1,1],ifelse(csur95$anno=="1990-01-01",common[2,1],ifelse(csur95$anno=="1991-01-01",common[3,1],ifelse(csur95$anno=="1992-01-01",common[4,1],ifelse(csur95$anno=="1993-01-01",common[5,1],ifelse(csur95$anno=="1994-01-01",common[6,1],ifelse(csur95$anno=="1995-01-01",common[7,1],ifelse(csur95$anno=="1996-01-01",common[8,1],ifelse(csur95$anno=="1997-01-01",common[9,1],ifelse(csur95$anno=="1998-01-01",common[10,1],ifelse(csur95$anno=="1999-01-01",common[11,1],common[12,1])))))))))))
csur95$dimm <- as.factor(ifelse(((round(csur95$quoimm, digits = 5) < round(csur95$pquoimm, digits = 5)) & (round(csur95$pquoimm, digits = 5) != ".")), 1, ifelse(round(csur95$quoimm, digits = 5)==".", ".", 0)))

csur95[grep("acqui",colnames(csur95))] <- NULL
csur95[grep("scorpo",colnames(csur95))] <- NULL
csur95[grep("isgru",colnames(csur95))] <- NULL
csur95[grep("^pav$",colnames(csur95))] <- NULL
  
csur95 <- csur95[order(csur95$identif),]
```
It is to be noticed here that generating quantiles with R and STATA gives slightly different values for **pquoimm** & **pofut**. The magnitude in differences is about 10<sup>-5</sup>. However this means that for one observation in the csur92 data set, **identif**=1839 for **anno**=1992 the resulting **duofut** variable has a value of 1 in R , while this value is 0 for STATA.<br>
Observe that in generating **duofut** & **dimm** variables, variables used to compute them out from were rounded to 5 digits. It is the number of digits that offers the minimum number of differences in csur95 between data generated with R and STATA.<br><br>
<table style="width:50%" border="9" align="center"> <caption>Differences Between R & STATA Generated csur95 Data Set</caption> <tr> <td>identif</td><td>anno</td><td>R</td><td>STATA</td></tr> <tr> <td>1839</td><td>1992</td><td>duofut = 1</td><td>duofut = 0</td></tr></table><br>
<h6 align="left">3 - Creating intermediary data set csur98</h6>
The creation of csur98 data set departs in three majors ways and in one major way from the construction of csur92 data set. First a minor adjustment in the selection of observation only contemporary to 1998.Here only observations current to 1998 (ranging 1995-1997) for firms in data set are selected and saved in csur98 data set. Additionally these firms should have a correct observation for number of employees the 3 years before (1995-1997) in order to be able to calculate labor growth. But authors seem to have added a condition that the age of the firm in 98 is not negative.<br>
Additionally a new variable **isgru** is introduced in the exact same manner as described for data set csur98.<br>
```{r, cache = TRUE}
csur98 <- subset(data,ind98 == 1 & dip97 != "." & dip97 > 0 & (eta98 >= 0 | is.na(eta98)))   
```
The baseline definition of financial constraints in the 1998 survey is defined somehow differently compared to both 1992 and 1995 surveys. The construction of financial constraint indicator **razd** is based on variables *desi*, *chie* and *paga* of the original data set. These variables represent code a yes or no question (1 being yes and 2 being no) to questions, "In the previous year the firm wanted more credit at the prevailing market conditions.", "In the previous year the firm asked for more credit but was turned down by the bank." and "In the previous year the firm would have accepted to pay a slightly higher loan rate." respectively.<br>
If answers to first question and second question both were positive, then the firm is considered as financially constrained and **razd** variable will be equal to 1, else if answers to all three questions were missing the firm is considered to be have no information on financial constraint having an NA value for **razd**, for all other situation the new variable will have a value of zero indicating no financial constraint of firm involved. A copy of this new variable is stored in variable **razd98d**.
```{r, cache = TRUE}
#Size as Proxied by Total Sales;
z <- ifelse(is.na(csur98$desi), 3, ifelse(csur98$desi == 1, 1, 2))
y <- ifelse(is.na(csur98$chie), 30, ifelse(csur98$chie == 1, 10, 20))
x <- ifelse(is.na(csur98$paga), 200, 100)
w <- z + y + x    

csur98$razd <- ifelse(w == 233, NA, ifelse(w == 111|w == 211, 1, 0))

csur98$raz98d <- csur98$razd

#Dummies M&A's;
csur98$duacq <- ifelse(is.na(csur98$acqui),0,ifelse(csur98$acqui==1,1,0))
csur98$dusco<- ifelse(is.na(csur98$scorpo),0,ifelse(csur98$scorpo==1,1,0))

#Dummy Industrial Group
csur98$isgru <- ifelse(is.na(csur98$isgru),0,ifelse(csur98$isgru==1,1,0))

#4 Pavitt Sectoral Dummies;
csur98$dupav1 <- ifelse(csur98$pav==1,1,0)
csur98$dupav2 <- ifelse(csur98$pav==2,1,0)
csur98$dupav3 <- ifelse(csur98$pav==3,1,0)
csur98$dupav4 <- ifelse(csur98$pav==4,1,0)

#Defining Balance-Sheet Variables
#Return on Assets
csur98$roa <- csur98$util/(csur98$aco + csur98$aim)
#Financial Expenses/Operating Profits
csur98$ofut <- ifelse(csur98$of/(csur98$of + csur98$utiln) == Inf, NA , csur98$of/(csur98$of + csur98$utiln))
#Share of Tangible Assets over Total Assets
csur98$quoimm <- csur98$imte/(csur98$aco + csur98$aim)
#Log of Sales
csur98$lsales <- ifelse(csur98$sales<= 0 , NA, log(csur98$sales))

#Generating Percentiles for the Dummies Low Coverage - Low Collateral
library(plyr)
common <- data.frame(tapply(csur98$ofut, csur98$anno, quantile, probs=.75, na.rm = TRUE))
a <- data.frame(rep(NA, times = 6))
b <- data.frame(rep(NA, times = (6 - nrow(common))))
names(common)[1] <- "common"
names(a)[1] <- "common"
names(b)[1] <- "common"
common <- data.frame(rbind(a, common, b))
csur98$pofut <- ifelse(csur98$anno=="1989-01-01",common[1,1],ifelse(csur98$anno=="1990-01-01",common[2,1],ifelse(csur98$anno=="1991-01-01",common[3,1],ifelse(csur98$anno=="1992-01-01",common[4,1],ifelse(csur98$anno=="1993-01-01",common[5,1],ifelse(csur98$anno=="1994-01-01",common[6,1],ifelse(csur98$anno=="1995-01-01",common[7,1],ifelse(csur98$anno=="1996-01-01",common[8,1],ifelse(csur98$anno=="1997-01-01",common[9,1],ifelse(csur98$anno=="1998-01-01",common[10,1],ifelse(csur98$anno=="1999-01-01",common[11,1],common[12,1])))))))))))

common <- data.frame(tapply(csur98$quoimm, csur98$anno, quantile, probs=.25, na.rm = TRUE))
a <- data.frame(rep(NA, times = 6))
b <- data.frame(rep(NA, times = (6 - nrow(common))))
names(common)[1] <- "common"
names(a)[1] <- "common"
names(b)[1] <- "common"
common <- data.frame(rbind(a, common, b))
csur98$duofut <- as.factor(ifelse(round(csur98$ofut, digits = 6) > round(csur98$pofut, digits = 6) & round(csur98$ofut, digits = 6) != ".",1,ifelse(round(csur98$ofut, digits = 6)==".",".",0)))

csur98$pquoimm <- ifelse(csur98$anno=="1989-01-01",common[1,1],ifelse(csur98$anno=="1990-01-01",common[2,1],ifelse(csur98$anno=="1991-01-01",common[3,1],ifelse(csur98$anno=="1992-01-01",common[4,1],ifelse(csur98$anno=="1993-01-01",common[5,1],ifelse(csur98$anno=="1994-01-01",common[6,1],ifelse(csur98$anno=="1995-01-01",common[7,1],ifelse(csur98$anno=="1996-01-01",common[8,1],ifelse(csur98$anno=="1997-01-01",common[9,1],ifelse(csur98$anno=="1998-01-01",common[10,1],ifelse(csur98$anno=="1999-01-01",common[11,1],common[12,1])))))))))))
csur98$dimm <- as.factor(ifelse(((round(csur98$quoimm, digits = 5) < round(csur98$pquoimm, digits = 5)) & (round(csur98$pquoimm, digits = 5) != ".")), 1, ifelse(round(csur98$quoimm, digits = 5)==".", ".", 0)))
```
A new variable **desi** is introduced here. This new variable is a dummy indicating if the firm desired more credit or not, based on *desi* variable in the original data set as described above. If the latter is equal to 1, **desi** variable will be equal to 1 indicating that the firm would have desired more credit the year in question. If all *desi*, *paga* and *chie* variables of the old data set had missing values the new **desi** variable will have an NA value. In any other case the value is equal to 0 indicating that firm did not need additional credit.<br>
A copy of this new variable **desi** is stored in new variable called **desi98**.
```{r, cache = TRUE}
#Dummy Desiring more Credit

a <- ifelse(is.na(csur98$desi), 3,ifelse(csur98$desi == 2, 2, 1))
b <- ifelse(is.na(csur98$chie), 20, 10)
c <- ifelse(is.na(csur98$paga), 200, 100)
d <- a + b + c
csur98$desi <- ifelse(d == 223, NA, ifelse(d == 111|d == 211|d == 121|d == 221, 1, 0))

csur98$desi98 <- csur98$desi

csur98[grep("acqui",colnames(csur98))] <- NULL
csur98[grep("scorpo",colnames(csur98))] <- NULL
csur98[grep("^pav$",colnames(csur98))] <- NULL

csur98 <- csur98[order(csur98$identif),]
```
It is to be noticed here that generating quantiles with R and STATA gives slightly different values for **pquoimm** & **pofut**. The magnitude in differences is about 10<sup>-5</sup>. However this means that for four observations in the csur98 data set the resulting **duofut**, and for one observation in the same data set the resulting **dimm** variables have differences for data sets generated using R and STATA.<br>
Observe that in generating **duofut** & **dimm** variables, variables used to compute them out from were rounded to 5 digits. It is the number of digits that offers the minimum number of differences in csur98 between data generated with R and STATA.<br><br>
<table style="width:50%" border="9" align="center"> <caption>Differences Between R & STATA Generated csur98 Data Set</caption> <tr> <td>identif</td><td>anno</td><td>R</td><td>STATA</td></tr> <tr> <td>1383790044</td><td>1997</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>1795940377</td><td>1995</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>7203080159</td><td>1996</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>327440278</td><td>1996</td><td>dimm = 1</td><td>dimm = 0</td></tr></table><br>

<h6 align="left">4 - Creating intermediary data set csur01</h6>
Here only observations current to 2001 (ranging 1998-200) for firms in data set are selected and saved in csur01 data set. Additionally these firms should have a correct observation for number of employees the 3 years before (1998-200) in order to be able to calculate labor growth. But authors seem to have added a condition that the age of the firm in 01 is not negative.<br>
As for the rest, the methods of creating the new variables are done in exactly the same manner as for <u>csur98</u>. Except that copies of new variable **razd** and **desi** for <u>csur01</u> data set are stored in variables **raz01d** and **desi01**.
```{r, cache = TRUE}
csur01 <- subset(data,ind01 == 1 & dip00 != "." & dip00 > 0 & (eta01 >= 0 | is.na(eta01)))
    
#Dummy Rationing Baseline def.
z <- ifelse(is.na(csur01$desi), 3, ifelse(csur01$desi == 1, 1, 2))
y <- ifelse(is.na(csur01$chie), 30, ifelse(csur01$chie == 1, 10, 20))
x <- ifelse(is.na(csur01$paga), 200, 100)
w <- z + y + x

csur01$razd <- ifelse(w == 233, NA, ifelse(w == 111|w == 211, 1, 0))

csur01$raz01d <- csur01$razd

#Dummies M&A's;
csur01$duacq <- ifelse(is.na(csur01$acqui),0,ifelse(csur01$acqui==1,1,0))
csur01$dusco<- ifelse(is.na(csur01$scorpo),0,ifelse(csur01$scorpo==1,1,0))

#Dummy Industrial Group
csur01$isgru <- ifelse(is.na(csur01$isgru),0,ifelse(csur01$isgru==1,1,0))

#4 Pavitt Sectoral Dummies;
csur01$dupav1 <- ifelse(csur01$pav==1,1,0)
csur01$dupav2 <- ifelse(csur01$pav==2,1,0)
csur01$dupav3 <- ifelse(csur01$pav==3,1,0)
csur01$dupav4 <- ifelse(csur01$pav==4,1,0)

#Defining Balance-Sheet Variables
#Return on Assets
csur01$roa <- csur01$util/(csur01$aco + csur01$aim)
#Financial Expenses/Operating Profits
csur01$ofut <- ifelse(csur01$of/(csur01$of + csur01$utiln) == Inf, NA , csur01$of/(csur01$of + csur01$utiln))
#Share of Tangible Assets over Total Assets
csur01$quoimm <- csur01$imte/(csur01$aco + csur01$aim)
#Log of Sales
csur01$lsales <- ifelse(csur01$sales<= 0 , NA, log(csur01$sales))

#Generating Percentiles for the Dummies Low Coverage - Low Collateral
library(plyr)
common <- data.frame(tapply(csur01$ofut, csur01$anno, quantile, probs=.75, na.rm = TRUE))
a <- data.frame(rep(NA, times = 9))
b <- data.frame(rep(NA, times = (3 - nrow(common))))
names(common)[1] <- "common"
names(a)[1] <- "common"
names(b)[1] <- "common"
common <- data.frame(rbind(a, common, b))
csur01$pofut <- ifelse(csur01$anno=="1989-01-01",common[1,1],ifelse(csur01$anno=="1990-01-01",common[2,1],ifelse(csur01$anno=="1991-01-01",common[3,1],ifelse(csur01$anno=="1992-01-01",common[4,1],ifelse(csur01$anno=="1993-01-01",common[5,1],ifelse(csur01$anno=="1994-01-01",common[6,1],ifelse(csur01$anno=="1995-01-01",common[7,1],ifelse(csur01$anno=="1996-01-01",common[8,1],ifelse(csur01$anno=="1997-01-01",common[9,1],ifelse(csur01$anno=="1998-01-01",common[10,1],ifelse(csur01$anno=="1999-01-01",common[11,1],common[12,1])))))))))))

common <- data.frame(tapply(csur01$quoimm, csur01$anno, quantile, probs=.25, na.rm = TRUE))
a <- data.frame(rep(NA, times = 9))
b <- data.frame(rep(NA, times = (3 - nrow(common))))
names(common)[1] <- "common"
names(a)[1] <- "common"
names(b)[1] <- "common"
common <- data.frame(rbind(a, common, b))
csur01$duofut <- as.factor(ifelse(round(csur01$ofut, digits = 6) > round(csur01$pofut, digits = 6) & round(csur01$ofut, digits = 6) != ".",1,ifelse(round(csur01$ofut, digits = 6)==".",".",0)))

csur01$pquoimm <- ifelse(csur01$anno=="1989-01-01",common[1,1],ifelse(csur01$anno=="1990-01-01",common[2,1],ifelse(csur01$anno=="1991-01-01",common[3,1],ifelse(csur01$anno=="1992-01-01",common[4,1],ifelse(csur01$anno=="1993-01-01",common[5,1],ifelse(csur01$anno=="1994-01-01",common[6,1],ifelse(csur01$anno=="1995-01-01",common[7,1],ifelse(csur01$anno=="1996-01-01",common[8,1],ifelse(csur01$anno=="1997-01-01",common[9,1],ifelse(csur01$anno=="1998-01-01",common[10,1],ifelse(csur01$anno=="1999-01-01",common[11,1],common[12,1])))))))))))
csur01$dimm <- as.factor(ifelse(((round(csur01$quoimm, digits = 5) < round(csur01$pquoimm, digits = 5)) & (round(csur01$pquoimm, digits = 5) != ".")), 1, ifelse(round(csur01$quoimm, digits = 5)==".", ".", 0)))

a <- ifelse(is.na(csur01$desi), 3,ifelse(csur01$desi == 2, 2, 1))
b <- ifelse(is.na(csur01$chie), 20, 10)
c <- ifelse(is.na(csur01$paga), 200, 100)
d <- a + b + c
csur01$desi <- ifelse(d == 223, NA, ifelse(d == 111|d == 211|d == 121|d == 221, 1, 0))

csur01$desi01 <- csur01$desi

csur01[grep("acqui",colnames(csur01))] <- NULL
csur01[grep("scorpo",colnames(csur01))] <- NULL
csur01[grep("^pav$",colnames(csur01))] <- NULL

csur01 <- csur01[order(csur01$identif),]
```
It is to be noticed here that generating quantiles with R and STATA gives slightly different values for **pquoimm** & **pofut**. The magnitude in differences is about 10<sup>-5</sup>. However this means that for two observations in the csur01 data set the resulting **duofut**, and for three observations in the same data set the resulting **dimm** variables have differences for data sets generated using R and STATA.<br>
Observe that in generating **duofut** & **dimm** variables, variables used to compute them out from were rounded to 5 digits. It is the number of digits that offers the minimum number of differences in csur98 between data generated with R and STATA.<br><br>
<table style="width:50%" border="9" align="center"> <caption>Differences Between R & STATA Generated csur01 Data Set</caption> <tr> <td>identif</td><td>anno</td><td>R</td><td>STATA</td></tr> <tr> <td>59520065</td><td>1999</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>1427530075</td><td>2000</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>1514750982</td><td>1999</td><td>dimm = 1</td><td>dimm = 0</td></tr><tr> <td>1588800986</td><td>2000</td><td>dimm = 1</td><td>dimm = 0</td></tr><tr> <td>2665140833</td><td>1998</td><td>dimm = 1</td><td>dimm = 0</td></tr></table><br>

<h4 align="left"> B - 1992 - 1995 and 1998 - 2001 surveys data sets & Main Data Sets Corrections</h4>
The 1992 - 1995 and 1998 - 2001 surveys data sets, eliminate both firms with errors in the age field of firms, and fills them if age is missing. However the latter can be done only for firms present on both years of each data set. They also create a dummy for persistently constrained firms.<br> Using these additional information, one can complete the main data sets created in section A above.
<h6 align="left">1 - 1992 - 1995 survey data set.</h6>
A new data set <u>csuro92</u> is created out of <u>csur92</u> data set, by taking only variables **raz92d** as defined in section A1, variables **eta92** and **identif**, present in original data set and representing the age of the firm in 1992 and a unique firm identifier respectively but exclusively for observations made on 1991.
```{r, cache = TRUE}
suppressMessages(library(lubridate))
csuro92 <- subset(csur92, year(csur92$anno) == 1991)
csuro92 <- data.frame(csuro92$identif, csuro92$eta92, csuro92$raz92d)
colnames(csuro92) <- c("identif", "eta92", "raz92d")
```
A new data set <u>csuro95</u> is created out of <u>csur95</u> data set, by taking only variables **raz95d** as defined in section A2, variables **eta95** and **identif**, present in original data set and representing the age of the firm in 1995 and a unique firm identifier respectively but exclusively for observations made on 1994.
```{r, cache = TRUE}
suppressMessages(library(lubridate))   
csuro95 <- subset(csur95, as.numeric(year(csur95$anno)) == 1994)
csuro95 <- data.frame(csuro95$identif, csuro95$eta95, csuro95$raz95d)
colnames(csuro95) <- c("identif", "eta95", "raz95d")

merge1 <- merge(csuro92, csuro95, by=c("identif"), all=TRUE)

ind1 <- ifelse(is.na(merge1$eta92) & is.na(merge1$raz92d), 1, 2)
ind2 <- ifelse(is.na(merge1$eta95) & is.na(merge1$raz95d), 10, 20)
ind3 <- ind1 + ind2
merge1$merge <- as.integer(ifelse(ind3 == 12, 1, ifelse(ind3 == 21, 2, ifelse(ind3 == 11, NA, 3))))

merge1 <- merge1[order(merge1$identif), ]
```
In the end, the two new data sets <u>csuro92</u> and <u>csuro95</u> are merged by **identif**, filling all very probable empty observations by an NA. The obtained data set is ordered by identif, and named <u>merge1</u>.<br>
What is done in the code chunk below is to compute the missing age data of a firm present in both surveys, but whose age in one survey is missing. A firm present in both 95 and 92 survey whose age in 95 is there, but for whom age in 92 is missing or illogical, age in 92 is set equal to age in 95 - 3.<br>
Similarly, a firm present in both 95 and 92 survey whose age in 92 is there, but for whom age in 95 is missing or illogical, age in 95 is set equal to age in 92 + 3. In any other case original observations of age from data sets <u>csuro92</u> and <u>csuro95</u> are kept. These new ages are stored in variables called **eta92c** and **eta95c**. Original **eta92** and **eta95** age variables are deleted.<br>
```{r, cache = TRUE}
#uses age from one survey to compute age.survey
merge1$eta92c <- ifelse((is.na(merge1$eta92)|merge1$eta92<0) & (!is.na(merge1$eta95) ) & merge1$merge == 3, merge1$eta95 - 3, merge1$eta92)
merge1$eta95c <- ifelse((is.na(merge1$eta95)|merge1$eta95<0) & (!is.na(merge1$eta92) ) & merge1$merge == 3, merge1$eta92 + 3, merge1$eta95)    

merge1[grep("^eta92$",colnames(merge1))] <- NULL
merge1[grep("^eta95$",colnames(merge1))] <- NULL
merge1[grep("^merge$",colnames(merge1))] <- NULL
```
What is done in the next code chunk is to create a **deta** variable that stores the differences in age between 1995 and 1992 as proxied by **eta95c** and **eta92c** as seen above. Then observations with large error in age field, or for deta superior to 5 or inferior to 1, observation is deleted. Next small differences in age field, for deta = 2 and = 4 the difference is squared to 3, by replacing value of **eta95c** by value of **eta92c** plus 3.
```{r, cache = TRUE}
#Drops firms in the balanced sample with large errors in the age field
merge1$deta <- merge1$eta95c - merge1$eta92c
merge1 <- subset(merge1,(merge1$deta > 1 |is.na(merge1$deta)) & (merge1$deta < 5 |is.na(merge1$deta)))
#forces small differences in age to square to 3
merge1$eta95c <- ifelse(is.na(merge1$deta), merge1$eta95c,ifelse(merge1$deta == 2 | merge1$deta == 4, merge1$eta92c + 3, merge1$eta95c))
```
In the last code chunk of this part, a dummy variable named **persist** is created as an indicator of persistently constrained firms. If the firm was financially constrained in 92 (**raz92d** equals 1) and in 95 (**raz95d** equals 1) then the firm is considered persistently financially constrained. Then **perist** equals 1, or 0 in any other case. Only variables **indentif**, **eta92c**, **eta95c** and **persist** are kept in the data set that is also ordered by **identif** variable.<br>
The end data set is then stored under the name <u>temp9295</u>.
```{r, cache = TRUE}
merge1$russia <- as.numeric(as.character(merge1$raz92d)) + as.numeric(as.character(merge1$raz95d))
merge1$persist <- as.factor(ifelse( is.na(merge1$russia), 0, ifelse(merge1$russia == 2, 1, 0)))
temp9295 <- data.frame(merge1$identif, merge1$eta92c, merge1$eta95c, merge1$persist)
colnames(temp9295) <- c("identif", "eta92c", "eta95c", "persist")
temp9295 <- temp9295 [order(temp9295$identif),]
```
In generating data set <u>temp9295</u> no differences were observed between data set generated with STATA and one generated with R.
<h6 align="left">2 - 1998 - 2001 survey data set.</h6>
Two new data sets <u>csuro98</u> and <u>csuro01</u> are created out of <u>csur98</u> and <u>csur01</u> data sets respectively, by taking only variables **raz92d** as defined in section A1, variables **eta92** and **identif**, present in original data set and representing the age of the firm in 1992 and a unique firm identifier respectively but exclusively for observations made on 1991. Then data sets are order by **identif** variable and renamed <u>temp98</u> and <u>temp01</u> respectively.<br>
In the end, the two new data sets are merged by **identif**, filling all very probable empty observations by an NA. The obtained data set is ordered by identif, and named <u>merge2</u>.<br>
```{r, cache = TRUE}
suppressMessages(library(lubridate))

csur98 <- read.table("~/Downloads/Desktop/Replication/erase/erasecsur98.txt", header=TRUE, quote="\"")
csuro98 <- subset(csur98, year(csur98$anno) == 1997)

temp98 <- csuro98[,c(31, 35, 43, 45, 60)]
temp98 <- temp98[order(temp98$identif),]

csur01 <- read.table("~/Downloads/Desktop/Replication/erase/erasecsur01.txt", header=TRUE, quote="\"")
csuro01 <- subset(csur01, year(csur01$anno) == 2000)

temp01 <- csuro01[,c(40, 41, 43, 45, 60)]
temp01 <- temp01[order(temp01$identif),]

merge2 <- merge(temp98, temp01, by = c("identif"), all = TRUE)
```
In the next code chunk age information from Cerved database in 98 is set to equal age in 2001 in same database minus 3. Then a new variable **diff** is created as the difference between age in 2001 and 1998 in the survey. for firms present in Cerved database.<br>
First, wrong or missing age information according to survey database is replaced by correct age information from Cerved database if available in the latter database. <br>
Then the missing age data of a firm present in both surveys, but whose age in one survey is missing is computed as follows. A firm present in both 98 and 01 survey and whose age in 01 is there, but for whom age in 98 is missing or illogical, age in 98 is set equal to age in 01 - 3.<br>
Similarly, a firm present in both 98 and 01 survey whose age in 98 is there, but for whom age in 01 is missing or illogical, age in 01 is set equal to age in 98 + 3. These new ages are stored in variables called **eta92c** and **eta95c**.<br>
```{r, cache = TRUE}
merge2$eta98n <- merge2$eta01n - 3
merge2$diff <- merge2$eta01 - merge2$eta98

merge2$diff <- ifelse(is.na(merge2$diff), 1000, merge2$diff)
merge2$eta01 <- ifelse(is.na(merge2$eta01), 1000, merge2$eta01)
merge2$eta01n <- ifelse(is.na(merge2$eta01n), -1000, merge2$eta01n)
merge2$eta98 <- ifelse(is.na(merge2$eta98), 1000, merge2$eta98)
merge2$eta98n <- ifelse(is.na(merge2$eta98n), -1000, merge2$eta98n)

merge2$eta98 <- ifelse(merge2$diff != 3 & merge2$eta01 == merge2$eta01n & merge2$eta98n != -1000 & merge2$eta98n >= 0, merge2$eta98n, merge2$eta98)
merge2$eta01 <- ifelse(merge2$diff != 3 & merge2$eta98 == merge2$eta98n & merge2$eta01n != -1000 & merge2$eta01n >= 0, merge2$eta01n, merge2$eta01)

merge2$eta98 <- ifelse(merge2$eta98 == 1000 & merge2$eta01 != 1000, merge2$eta01 - 3, merge2$eta98)
merge2$eta98 <- ifelse(merge2$eta98 < 0 & merge2$eta01 != 1000, merge2$eta01 - 3, merge2$eta98)

merge2$eta01 <- ifelse((merge2$eta01 == 1000 | merge2$eta01 < 0) & merge2$eta98 != 1000, merge2$eta98 + 3, merge2$eta01)

merge2$eta98 <- ifelse(merge2$eta98 == 1000, NA, merge2$eta98)
merge2$eta01 <- ifelse(merge2$eta01 == 1000, NA, merge2$eta01)
```
What is done in the next code chunk is to create a **deta** variable that stores the differences in age between 1998 and 2001 as proxied by **eta98** and **eta01** as seen above. Then observations with large error in age field, or for deta superior to 5 or inferior to 1, observation is deleted. Next small differences in age field, for deta = 2 and = 4 the difference is squared to 3, by replacing value of **eta01** by value of **eta92c** plus 3.
```{r, cache = TRUE}
merge2$deta <- merge2$eta01 - merge2$eta98
merge2 <- subset(merge2,(merge2$deta > 1| is.na(merge2$deta)) & (merge2$deta < 5| is.na(merge2$deta)))

merge2$deta<- ifelse(is.na(merge2$deta), 1000, merge2$deta)
merge2$eta01 <- ifelse(merge2$deta==2|merge2$deta==4, merge2$eta98 + 3, merge2$eta01)
```
In the last code chunk of this part, two dummy variable named **persist** and **perdesi** are created as an indicators of persistently constrained firms and firms in persistently desiring more credit. If the firm was financially constrained in 92 (**raz92d** equals 1) and in 95 (**raz95d** equals 1) then the firm is considered persistently financially constrained.Then **perist** equals 1, or 0 in any other case. If the firm desired more credit  in 98 (**desi98** equals 1) and in 01 (**desi01** equals 1) then the firm is considered persistently in need of more credit.Then **perdesi** equals 1, or 0 in any other case.<br>
Age indicating variables **eta01** and **eta98** are renamed **eta01c** and **eta98c** respectively.<br>
Only variables **indentif**, **eta92c**, **eta95c** and **persist** are kept in the data set that is also ordered by **identif** variable.<br>
The end data set is then stored under the name <u>temp9801</u>.
```{r, cache = TRUE}
a <- ifelse(is.na(merge2$raz98d), 3, ifelse(merge2$raz98d == 1, 1, 2))
b <- ifelse(is.na(merge2$raz01d), 3, ifelse(merge2$raz01d == 1, 1, 2))
c <- a + b
merge2$persist <- ifelse(c == 2, 1, 0)

d <- ifelse(is.na(merge2$desi98), 3, ifelse(merge2$desi98 == 1, 1, 2))
e <- ifelse(is.na(merge2$desi01), 3, ifelse(merge2$desi01 == 1, 1, 2))
f <- d + e
merge2$perdesi <- ifelse(f == 2, 1, 0)
temp9801 <- merge2[,c(1, 2, 6, 12, 13)]
names(temp9801)[2]="eta98c"
names(temp9801)[3]="eta01c"

temp9801 <- temp9801[order(temp9801$identif),]
```
In generating data set <u>temp9801</u> no differences were observed between data set generated with STATA and one generated with R.
<h6 align="left">3 - 1992 - 1995 main data set corrections</h6>
The goal in this part of data manipulation is to correct the age fields in the main data sets using the temporary data sets generated in the two previous sections. In this part, data set <u>temp9295</u> is used to correct age fields in main data sets <u>csur92</u> and <u>csur95</u>.<br>
In the next section of code, data set <u>temp9295</u> and <u>csur92</u> are merged by **identif** variable. Next a merge indicator variable is added to data set thus obtained. Knowing that variable **pofut** has no missing values in <u>csur92</u> and **persist** in <u>temp9801</u> data set, we use this information to code **merge** variable. If information in a specific row comes only from <u>csur92</u> data set then **pofut** will have no missing value for this row while **persist** will be. If information in a specific row comes only from <u>temp9295</u> the inverse is true. In the first case, **merge** variable will have value of 1 and in the second case a value of 2. But if information in specific row comes from both data sets, then **merge** variable will have a value of 3.<br>
Observe that only rows having information from both data sets are kept in the end. Then age computed in <u>temp9295</u> replaces age fields in main data set only for 1992. The value for variable **persist** indicating persistently constrained firms is set to equal to zero for all observations as 92 is the first year considered here.<br>
In the end, variables **merge**, **eta92** and **eta95** are kicked out of the data set, and also observations having negative age value for 1992. Data is ordered by **identif** and by **anno** then saved under the name <u>csur92</u>.
```{r, cache = TRUE}
# Merging csur92 & temp9295 data sets
merge3 <- merge(csur92, temp9295, by=c("identif"))

#Creating merge indicator
a <- ifelse(is.na(merge3$pofut), 0, 1)
b <- ifelse(is.na(merge3$persist), 10, 20)
c <- a + b
merge3$merge <- ifelse(c == 11, 1, ifelse(c == 20, 2, 3))

#subsetting rows with info from both data sets
merge3 <- subset(merge3, merge3$merge == 3)

#correcting age fields
merge3$eta92 <- merge3$eta92c
#correcting persistance of financial constraints
merge3$persist <- rep(0, times = nrow(merge3))

#Kicking out merge, eta92c & eta95c & observation with illogical age fields
merge3[grep("^merge$",colnames(merge3))] <- NULL
merge3[grep("^eta92c$",colnames(merge3))] <- NULL
merge3[grep("^eta95c$",colnames(merge3))] <- NULL
merge3 <- subset(merge3, (is.na(merge3$eta92)|merge3$eta92 >= 0))

# Ordering data & renaming csur92
csur92 <- merge3 [order(merge3$identif, merge3$anno),]
```
The same treatment is given to <u>csur95</u> data set. Except that information regarding persistence of financial constraint for firms, or **persist** variable, is not reset to zero but keep the original values that they took in <u>temp9295</u> data set. Then age computed in <u>temp9295</u> replaces age fields in main data set only for 1995. And at the end it is observations with illogical for age in 1995 that are kicked out of the data set.<br>
Resulting data set is saved under <u>csur95</u>.
```{r, cache = TRUE}
# Merging csur92 & temp9295 data sets
merge4 <- merge(csur95, temp9295, by=c("identif"))

#Creating merge indicator
a <- ifelse(is.na(merge4$pofut), 0, 1)
b <- ifelse(is.na(merge4$persist), 10, 20)
c <- a + b
merge4$merge <- ifelse(c == 11, 1, ifelse(c == 20, 2, 3))

#subsetting rows with info from both data sets
merge4 <- subset(merge4, merge4$merge == 3)

#correcting age fields
merge4$eta95 <- merge4$eta95c

merge4[grep("^merge$",colnames(merge4))] <- NULL
merge4[grep("^eta92c$",colnames(merge4))] <- NULL
merge4[grep("^eta95c$",colnames(merge4))] <- NULL

#Kicking out merge, eta92c & eta95c & observation with illogical age fields
merge4 <- subset(merge4, (is.na(merge4$eta95)|merge4$eta95 >= 0))

# Ordering data & renaming csur95
csur95 <- merge4 [order(merge4$identif, merge4$anno),]
```
The only differences noted in these two new data sets <u>csur92</u> and <u>csur95</u>, between ones generated with R and with STATA, are differences noted in parts A - 1 and A - 2 respectively for the two data sets.
<h6 align="left">4 - 1998 - 2001 main data set corrections</h6>
In this part, data set <u>temp9801</u> is used to correct age fields in main data sets <u>csur98</u> and <u>csur01</u>.<br>
In the next section of code, data set <u>temp9801</u> and <u>csur98</u> are merged by **identif** variable. Next a merge indicator variable is added to data set thus obtained. Knowing that variable **pofut** has no missing values in <u>csur98</u> and **persist** in <u>temp9801</u> data set, we use this information to code **merge** variable. If information in a specific row comes only from <u>csur98</u> data set then **pofut** will have no missing value for this row while **persist** will be. If information in a specific row comes only from <u>temp9801</u> the inverse is true. In the first case, **merge** variable will have value of 1 and in the second case a value of 2. But if information in specific row comes from both data sets, then **merge** variable will have a value of 3.<br>
Observe that only rows having information from both data sets are kept in the end. Then age computed in <u>temp9801</u> replaces age fields in main data set only for 1998, if available. The value for variable **persist** indicating persistently constrained firms and **perdesi** indicating firms persistently in need of more credit are set to equal to zero for all observations as 98 is the first year considered here.<br>
In the end, variables **merge**, **eta98c** and **eta01c** are kicked out of the data set. Data is ordered by **identif** and by **anno** then saved under the name <u>csur98</u>.
```{r, cache = TRUE}
merge5 <- merge(csur98, temp9801, by=c("identif"))
a <- ifelse(is.na(merge5$pofut), 0, 1)
b <- ifelse(is.na(merge5$persist), 10, 20)
c <- a + b
merge5$merge <- ifelse(c == 11, 1, ifelse(c == 20, 2, 3))

merge5$eta98 <- ifelse(is.na(merge5$eta98c), merge5$eta98, merge5$eta98c)

merge5[grep("^eta98c$",colnames(merge5))] <- NULL
merge5[grep("^eta01c$",colnames(merge5))] <- NULL

merge5$persist <- rep(0, times = nrow(merge5))
merge5$perdesi <- rep(0, times = nrow(merge5))

merge5 <- subset(merge5, merge5$merge == 3)
merge5[grep("^merge$",colnames(merge5))] <- NULL

csur98 <- merge5 [order(merge5$identif, merge5$anno),]
```
The same treatment is given to <u>csur01</u> data set. Except that information regarding persistence of financial constraint for firms, or **persist** variable and persistence of desire of more credit from firms **perdesi**, are not reset to zero but keep their original values that they took in <u>temp9801</u> data set. Then age computed in <u>temp9801</u> replaces age fields in main data set only for 2001. <br>
Resulting data set is saved under <u>csur01</u>.
```{r, cache = TRUE}
merge6 <- merge(csur01, temp9801, by=c("identif"))
a <- ifelse(is.na(merge6$pofut), 0, 1)
b <- ifelse(is.na(merge6$persist), 10, 20)
c <- a + b
merge6$merge <- ifelse(c == 11, 1, ifelse(c == 20, 2, 3))

merge6$eta01 <- ifelse(is.na(merge6$eta01c), merge6$eta01, merge6$eta01c)

merge6[grep("^eta98c$",colnames(merge6))] <- NULL
merge6[grep("^eta01c$",colnames(merge6))] <- NULL

merge6 <- subset(merge6, merge6$merge == 3)
merge6[grep("^merge$",colnames(merge6))] <- NULL

csur01 <- merge6 [order(merge6$identif, merge6$anno),]
```
The only differences noted in these two new data sets <u>csur98</u> and <u>csur01</u>, between ones generated with R and with STATA, are differences noted in parts A - 3 and A - 4 respectively for the two data sets.<br>
<h4 align="left"> C - tempstime Data Set</h4>
In part C of the replication process, data set tempstime_1 data set used for all OLS and GMM regressions in the original paper by the authors is reproduced. This is done in four different steps.<br>
<h6 align="left">1 - Append the Main Data Sets</h6>
In the first of for steps, main data sets <u>csur92</u>, <u>csur95</u>, <u>csur98</u> and <u>csur01</u> are all appended together to form one big data set. But before appending the data sets a variable **eta** is created for each data sets out of variables **eta92**, **eta95**, **eta98** and **eta01** respectively. If year of observation for a specific firm is 1990, 1993, 1996 or 1999 then **eta** is set equal to **eta92**, **eta95**, **eta98** and **eta01** minus one respectively. And if year of observation for a specific firm is 1989, 1992, 1995 or 1998 then **eta** is set equal to **eta92**, **eta95**, **eta98** and **eta01** minus two respectively.<br>
The data set resulting from the appending process is stored under the name <u>merge7</u> after data is ordered by **identif** and **anno**.
```{r, cache = TRUE}
library(lubridate)

csur92$eta <- ifelse(is.na(csur92$eta92), NA, csur92$eta92)
csur92$eta <- ifelse(!is.na(csur92$eta92) & year(csur92$anno) == 1990, csur92$eta - 1, csur92$eta)
csur92$eta <- ifelse(!is.na(csur92$eta92) & year(csur92$anno) == 1989, csur92$eta - 2, csur92$eta)
csur92 <- csur92 [order(csur92$identif, csur92$anno),]

csur95$eta <- ifelse(is.na(csur95$eta95), NA, csur95$eta95)
csur95$eta <- ifelse(!is.na(csur95$eta95) & year(csur95$anno) == 1993, csur95$eta - 1, csur95$eta)
csur95$eta <- ifelse(!is.na(csur95$eta95) & year(csur95$anno) == 1992, csur95$eta - 2, csur95$eta)
csur95 <- csur95 [order(csur95$identif, csur95$anno),]

csur98$eta <- ifelse(is.na(csur98$eta98), NA, csur98$eta98)
csur98$eta <- ifelse(!is.na(csur98$eta98) & year(csur98$anno) == 1996, csur98$eta - 1, csur98$eta)
csur98$eta <- ifelse(!is.na(csur98$eta98) & year(csur98$anno) == 1995, csur98$eta - 2, csur98$eta)
csur98 <- csur98 [order(csur98$identif, csur98$anno),]

csur01$eta <- ifelse(is.na(csur01$eta01), NA, csur01$eta01)
csur01$eta <- ifelse(!is.na(csur01$eta01) & year(csur01$anno) == 1999, csur01$eta - 1, csur01$eta)
csur01$eta <- ifelse(!is.na(csur01$eta01) & year(csur01$anno) == 1998, csur01$eta - 2, csur01$eta)
csur01 <- csur01 [order(csur01$identif, csur01$anno),]

merge7 <- merge(merge(csur92, csur95, all.x = TRUE, all.y = TRUE), merge(csur98, csur01, all.x = TRUE, all.y = TRUE), all.x = TRUE, all.y = TRUE)
merge7 <- merge7[order(merge7$identif,merge7$anno),]
```
Except for the small differences in some variables, in the order of 10<sup>-5</sup> or 10<sup>-4</sup> in some variables, the only differences noted between the data set formed using R and using STATA at this stage comes from the differences noted in the four tables in Section B. For reminder let's note these differences in the table below.<br><br>
<table style="width:50%" border="9" align="center"> <caption>Differences Between R & STATA Generated merge7 Data Set</caption> <tr> <td>identif</td><td>anno</td><td>R</td><td>STATA</td></tr> <tr> <td>11636</td><td>1991</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>1839</td><td>1992</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>1383790044</td><td>1997</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>1795940377</td><td>1995</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>59520065</td><td>1999</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>1514750982</td><td>1999</td><td>dimm = 1</td><td>dimm = 0</td></tr><tr> <td>1588800986</td><td>2000</td><td>dimm = 1</td><td>dimm = 0</td></tr><tr> <td>2665140833</td><td>1998</td><td>dimm = 1</td><td>dimm = 0</td></tr></table><br>
<h6 align="left">2 - LAGS and LEADS in tempstime Data Set</h6>

```{r, cache = TRUE}
### Generating lags
library(lubridate)
merge7 <-  within(merge7, { 
        detab <- ave(eta, identif, FUN = function(x) c(NA, diff(x))) 
        roa1 <- ave(roa, identif, FUN = function(x) c(NA, x[-length(x)]))
        danno <- ave(year(merge7$anno), identif, FUN = function(x) c(NA, diff(x))) 
})

merge7$dip <- ifelse(year(merge7$anno)==1989,merge7$dip89,ifelse(year(merge7$anno)==1990,merge7$dip90,ifelse(year(merge7$anno)==1991,merge7$dip91,ifelse(year(merge7$anno)==1992,merge7$dip92,ifelse(year(merge7$anno)==1993,merge7$dip93,ifelse(year(merge7$anno)==1994,merge7$dip94,ifelse(year(merge7$anno)==1995,merge7$dip95,ifelse(year(merge7$anno)==1996,merge7$dip96,ifelse(year(merge7$anno)==1997,merge7$dip97,ifelse(year(merge7$anno)==1998,merge7$dip98,ifelse(year(merge7$anno)==1999,merge7$dip99,merge7$dip00)))))))))))

merge7$identif <- as.factor(merge7$identif)

# Creating identif LAG by identif
E <- data.frame(as.factor(merge7$identif))
G <- data.frame(rbind(as.character(NA), E))
G <- data.frame(G[-nrow(G),])
H <- data.frame(cbind(E, G))
colnames(H) <- c("nlg", "lg1")
H$rl <- ifelse(H$nlg == H$lg1, as.character(H$nlg), NA)

# Creating identif LEAD by identif
I <- data.frame(rbind(E, as.character(NA)))
I <- data.frame(I[-1,])
J <- data.frame(cbind(E, I))
colnames(J) <- c("nad", "ad1")
J$ra <- ifelse(J$nad == J$ad1, as.character(J$nad), NA)

# identif LAG is called id1 and LEAD id3 (by identif)
merge7$id1 <- H$rl
merge7$id3 <- J$ra

# creating dip1, dip2 and dip3 variables which represent number of firms by identif
# lagged one time, two times and leaded one time respectively
suppressMessages(library(data.table))
merge7 <- data.table(merge7, key = "identif")
merge7[,c("dip1") := list(c(NA, dip[-.N])), by = identif]
merge7[,c("dip2") := list(c(NA, dip1[-.N])), by = identif]

merge7 <- merge7[order(merge7$identif, merge7$anno, decreasing = TRUE)]
merge7[,c("dip3") := list(c(NA, dip[-.N])), by = identif]
merge7 <- merge7[order(merge7$identif, merge7$anno, decreasing = FALSE)]

# Interpolating possible missing values of number of employees in firm
# Missing value is filled by averaging the number of employees in firm
# exactly from one year before and after if they exist for the specific firm
merge7$dip <- ifelse(is.na(merge7$dip) & !is.na(merge7$dip3) & !is.na(merge7$dip1) & merge7$id1 == merge7$id3, (merge7$dip3+merge7$dip1)/2, merge7$dip)

# Growth rate in number of employees (ddip)
merge7$ddip <- ((merge7$dip-merge7$dip1)/merge7$dip1)

# log of number of employees the same year for the specific firm, a year before
# and two years before (resp. ldip, ldip1 and ldip2)
suppressWarnings(merge7$ldip <- ifelse(is.infinite(log(merge7$dip)), NA, log(merge7$dip)))
suppressWarnings(merge7$ldip1 <- ifelse(is.infinite(log(merge7$dip1)), NA, log(merge7$dip1)))
suppressWarnings(merge7$ldip2 <- ifelse(is.infinite(log(merge7$dip2)), NA, log(merge7$dip2)))

merge7 <- data.frame(merge7)

merge7$id1 <- NULL
merge7$id3 <- NULL
merge7$dip1 <- NULL
merge7$dip2 <- NULL
merge7$dip3 <- NULL
```

<h6 align="left">3 - Indicators in tempstime Data Set</h6>
<br>
<h6><sup>1</sup>Angelini, Paolo, and Andrea Generale. 2008. "On the Evolution of Firm Size Distributions." American Economic Review, 98(1): 426-38.</h6>
