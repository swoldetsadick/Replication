---
title: "On the Evolution of Firm Size Distributions"
author: "Woldetsadick Selam Getachew"
date: "Monday, September 15, 2014"
output: html_document
---
<h4,align="left>Replication of findings [A,Paolo & A,Generale (2008)](http://www.jstor.org/discover/10.2307/29729977?uid=3737864&uid=2&uid=4&sid=21104166174021)<sup>1</sup></h4>
<br>
```{r set-options, cache = TRUE}
```
```{r,echo = FALSE, results = 'hide', cache = TRUE}
old.loc <- Sys.getlocale("LC_TIME")
Sys.setlocale(category = "LC_TIME", locale="English")
time <- format(Sys.time(),"%a, %b %d %Y, %X")
version <- R.Version()
varsion <- version[[13]]
old.loc <- Sys.getlocale("LC_TIME")
```

<h1 align="center">Motivation</h1>
<hr width="100%"  noshade size=4>

This work is an attempt at a **replication** of Angelini Paolo and Andrea Generale's 2008 article entitled *On the Evolution of Firm Size Distributions* and published in the American Economic Review<sup>1</sup>.Econometric study for the original article was implemented in SAS statistical analysis software, in this replication R a different statistical analysis software will be used.The goal of this replication work is to indeed replicate findings of the original authors of the article, and extend their results.<br>
The raw data and code books pdf can be found [here](http://www.aeaweb.org/aer/data/mar08/20050397_data.zip) for downloading.<br>
The following analysis was made using the `r time` version of the raw data, and `r varsion` version of R combined with RStudio Desktop v0.98.1056 front.<br> 
<br>
<br>

<h1 align="center">Introduction</h1>
<hr width="100%" noshade size=4>
hereinafter the study

<br>
<br>

<h1 align="center">Loading and pre-processing raw data</h1>
<hr width=100% noshade size=4>
<h4 align="left"> A - Loading the Data</h4>
This chuck of R code uses `dowloader` library to download directly data from the url specified in *url* symbol. The data thus obtained is unzipped using `unzip` function and stored in *ori* symbol. After data is coerced into a matrix aspect and  assigned *mat* symbol, first column - second line of said matrix, corresponding to raw data, is loaded using `read.dta` function of `foreign` library.The raw is therefore named *data* in R.<br>
Also `shell.exec` function is used to open the code book for user automatically. Make sure you have a pdf reader installed.
```{r, cache = TRUE}
library(foreign)
library(downloader)
setwd("C:/Users/anton_000/Documents/Downloads/Desktop/Replication")
url <- "http://www.aeaweb.org/aer/data/mar08/20050397_data.zip"
download(url,"datasur.dat", mode="wb")
ori <- unzip("datasur.dat")
mat <- matrix(ori)
data <- read.dta(mat[2,1])
shell.exec(file.path(getwd(), "readme.pdf"))
```
<br>
<h4 align="left"> B - Pre-processing the Data</h4>
First a quick look at the names of columns in the data set charged in R environment to compare it with **readme.pdf** listed variables, and also the classes of all variables to match with information in readme file.
```{r, cache = TRUE}
names <- names(data) #storing column names in "names" vector
classes <- rep(0, times=ncol(data)) # creating vector to store classes of data column
for(i in 1:ncol(data)) {classes[i] <- class(data[,i])} # for each column in data finding class storing it in vector "classes" 
names #displaying names
classes# displaying classes
```
<br>As can be seen above although all variables listed in the readme file are present in our data set, all of them seem to have a numeric class in R. However, variable *anno* should be treated as a variable of **Date class** and variables *ACO*, *AIM*, *SALES*, *sales*, *UTIL*, *UTILN*, *OF*, *IMIM* and *IMTE* should have **class numeric**, *indentif* **class factor**, while *the rest* should have **class integer**.<br>
In the following chunk of code does exactly that.
```{r, cache = TRUE}
data$anno <- as.Date(paste(as.character(data$anno),paste("01","01",sep="-"),sep="-"),"%Y-%m-%d") # changing class for anno variable to date
data$identif <- as.factor(data$identif) # indentif number is treated as factor
classes <- rep(0, times=ncol(data)) # creating vector to store classes of data column
for(i in 1:ncol(data)) {classes[i] <- class(data[,i])} # for each column in data finding class storing it in vector "classes" 
classes # displaying classes
```
It can be seen above that classes of variables in the data set are made to match expectations in view of code book. Also note that month and day of observations have been set to default 01-01 because they are unavailable in raw data. <br>
Now that this pre-processing of data is finished, the process of tidying the data and making it "regression" friendly can start. 
<br>
<br>
<h1 align="center">Generating estimation data sets</h1>
<h4 align="center">Transcribing data set.do and obtaining open9201.dta, closed9201.dta and tempstime_1.dta</h3>
<hr width="100%" noshade size=4>

<h4 align="left"> A - Main Data Sets</h4>
The code chunks in the following sub-part of this document loads the Mediocredito Survey & Balance Sheet data containing information for each individual firms for each four years separately, generates and saves relevant variables used in the original paper.<br>
Data from each different years need slightly adjusted code to process them compared to one another.<br>

<h6 align="left">1 - Creating intermediary data set csur92</h6>
Generating data for firms observed in 1992, each have unique identifier that they keep over the years.<br>
Here only observations current to 1992 (ranging 1989-1991) for firms in data set are selected and saved in csur92 data set. Additionally these firms should have a correct observation for number of employees the 3 years before (1989-1991) in order to be able to calculate labor growth.<br>
```{r, cache=TRUE}
csur92 <- subset(data,ind92==1 & dip91!="." & dip91>0)     
```
Now that only observations only from 1992 are chosen via indicator ind==92, relevant variables can be are created.<br>
In the code chunk below the log of size of sales (expressed in thousand euros) variable **lsize** is created. This will serve as proxy for size of firm.
```{r, cache=TRUE}
csur92$lsize <- ifelse(csur92$sales<= 0 , NA, log(csur92$sales))    
```
In the next chunk of code, dummies establishing baseline definition of rationing, or financial constraint, are constructed out of *d17_1*, *d17_2*, *d17_3* or *d17_4* variables.These variables are coded answers for questions of whether or not a firm encountered difficulties in financing their last investment project due to insufficient cash flow, lack of collateral, insufficient long-term finance or high cost of debt respectively. In this case multiple answers were allowed with an intensity ranking from 1 to 3, missing values being coded as equal to 9.<br>
As indicated in p.427 of the original article, "In the 1992 survey, we define a firm as constrained if at least one question of the first four causes was given the highest importance." Hence the new rationing variable **razd** takes a value of 1, indicating a financially constrained firm, if above conditions are met, NA if observations for all four original variables are equal to 9, or missing, 0 in any other case.<br>
A duplicated of **razd** variable therefore created is stored under the label **raz92d**.
```{r, cache=TRUE}
csur92$razd <- as.factor(ifelse(csur92$d17_1==3|csur92$d17_2==3|csur92$d17_3==3|csur92$d17_4==3,1,ifelse(csur92$d17_1==9 &csur92$d17_2==9 & csur92$d17_3==9 & csur92$d17_4==9,NA,0)))
csur92$raz92d <- csur92$razd    
```
In the next chunk of code, Merger and Acquisition indicators are created. A new variable **duacq** is coded as being equal to 1 if the firm was party to mergers or acquisition, and takes 0 in cases of both missing value or if the firm not being party to m&a. This new variable is a version of ACQUI variable in original data set.<br>
A new variable **dusco** is created as being equal to 1 if the firm was created through a spin off, and takes 0 in cases of both missing value or if the firm was not created through a spin off.This new variable is a version of SCORPO variable in original data set.<br>
```{r, cache = TRUE}
csur92$duacq <- ifelse(is.na(csur92$acqui),0,ifelse(csur92$acqui==1,1,0))   
csur92$dusco<- ifelse(is.na(csur92$scorpo),0,ifelse(csur92$scorpo==1,1,0))
```
In the next code chunk, sectoral dummies according to "Keith Pavitt" classification are given. In the original data the information is coded in PAV variable which takes values of 1 to 4 if firm belongs to traditional sector, or is scale intensive, or is a specialized supplier, or a high technology respectively. However in the present data set, this variable is separated into four, each specifically answering to one question. **dupav1** answers if firm is in traditional sector taking value 1 or not taking value 0. **dupav2** answers if firm is scale intensive taking value 1 or not taking value 0. **dupav3** answers if firm is a specialized supplier taking value 1 or not taking value 0. **dupav4** answers if firm is in high-technology taking value 1 or not taking value 0.
```{r, cache = TRUE}
csur92$dupav1 <- ifelse(csur92$pav == 1, 1, 0)
csur92$dupav2 <- ifelse(csur92$pav == 2, 1, 0)   
csur92$dupav3 <- ifelse(csur92$pav == 3, 1, 0)
csur92$dupav4 <- ifelse(csur92$pav == 4, 1, 0) 
```
In the next code chunk, balance sheet variables are defined. Variable **roa** represents the return on assets, as a ratio of earnings before financial expense, coded as variable UTIL in the original data set, over the sum of current & net fixed assets, coded as variable ACO and AIM respectively in the original data set.Variable **ofut** represents a ratio of financial expenses represented by variable of in original data set, over operating profits as sum of financial expenses themselves and earnings before taxes and extraordinary items. It defines in essence the share of financial expenses in operating profits.<br>
Variable **quoimm** represents the share of tangible assets, coded by variable IMTE in the original data set, over total assets defined as a sum between current and net fixed assets. Moreover, a new **lsales** variables which represents log of sales number is introduced. All balance sheet variables are expressed in thousands euros.
```{r, cache = TRUE}
csur92$roa <- (csur92$util/(csur92$aco+csur92$aim))
csur92$ofut <- (csur92$of/(csur92$of+csur92$utiln))   
csur92$quoimm <- (csur92$imte/(csur92$aco+csur92$aim))
csur92$lsales <- ifelse(csur92$sales<= 0 , NA, log(csur92$sales))
```
The next code chunks generate dummies for low coverage or low collateral. The rationale behind it can be explained as follows. If the ratio of financial expenses over operating profits, as represented by variable **ofut**, is high, one can conclude that the firm is confronted with high cost of debt and has hence a low coverage. In the same manner, if the share of tangible assets over total asset, as represented by variable **quoimm** is low, one can conclude that the firm in question is confronted to insufficient collateral.
Then we create variables **pofut** and **pquoimm** that represent 75<sup>th</sup> by year of the ratio financial expenses over operating profits, and 25<sup>th</sup> percentile by year of the share of tangible assets over total assets.<br>
At last, variable **duofut** is an indicator of low coverage, taking value of 1 if value of financial expenses over operating profits for that year for that firm is in the 25%  higher values indicating low coverage, 0 if not. In the same manner, variable **dimm** indicates low collateral, taking a value of 1 if the share of tangible assets over total assets for that firm in that year is in the lowest 25%, indicating low collateral, and 0 if not. At last data is ordered by the *identif* variable.
```{r, cache = TRUE}
library(plyr)
common <- data.frame(tapply(csur92$ofut, csur92$anno, quantile, probs=.75, na.rm = TRUE))
a <- data.frame(rep(NA, times = (12 - nrow(common))))
names(common)[1] <- "common"
names(a)[1] <- "common"
common <- data.frame(rbind(common,a))
csur92$pofut <- ifelse(csur92$anno=="1989-01-01",common[1,1],ifelse(csur92$anno=="1990-01-01",common[2,1],ifelse(csur92$anno=="1991-01-01",common[3,1],ifelse(csur92$anno=="1992-01-01",common[4,1],ifelse(csur92$anno=="1993-01-01",common[5,1],ifelse(csur92$anno=="1994-01-01",common[6,1],ifelse(csur92$anno=="1995-01-01",common[7,1],ifelse(csur92$anno=="1996-01-01",common[8,1],ifelse(csur92$anno=="1997-01-01",common[9,1],ifelse(csur92$anno=="1998-01-01",common[10,1],ifelse(csur92$anno=="1999-01-01",common[11,1],common[12,1])))))))))))

common <- data.frame(tapply(csur92$quoimm, csur92$anno, quantile, probs=.25, na.rm = TRUE))
b <- data.frame(rep(NA, times = (12 - nrow(common))))
names(common)[1] <- "common"
names(b)[1] <- "common"     
common <- data.frame(rbind(common, b))
csur92$duofut <- as.factor(ifelse(round(csur92$ofut, digits = 4) > round(csur92$pofut, digits = 4) & round(csur92$ofut, digits = 4) != ".",1,ifelse(round(csur92$ofut, digits = 4)==".",".",0)))

csur92$pquoimm <- ifelse(csur92$anno=="1989-01-01",common[1,1],ifelse(csur92$anno=="1990-01-01",common[2,1],ifelse(csur92$anno=="1991-01-01",common[3,1],ifelse(csur92$anno=="1992-01-01",common[4,1],ifelse(csur92$anno=="1993-01-01",common[5,1],ifelse(csur92$anno=="1994-01-01",common[6,1],ifelse(csur92$anno=="1995-01-01",common[7,1],ifelse(csur92$anno=="1996-01-01",common[8,1],ifelse(csur92$anno=="1997-01-01",common[9,1],ifelse(csur92$anno=="1998-01-01",common[10,1],ifelse(csur92$anno=="1999-01-01",common[11,1],common[12,1])))))))))))
csur92$dimm <- as.factor(ifelse(((round(csur92$quoimm, digits = 4) < round(csur92$pquoimm, digits = 4)) & (round(csur92$pquoimm, digits = 4) != ".")), 1, ifelse(round(csur92$quoimm, digits = 4)==".", ".", 0)))

csur92[grep("acqui",colnames(csur92))]=NULL
csur92[grep("scorpo",colnames(csur92))]=NULL
csur92[grep("^pav$",colnames(csur92))]=NULL
csur92 <- csur92[order(csur92$identif),]
a <- csur92[8184, 58]     
```
It is to be noticed here that generating quantiles with R and STATA gives slightly different values for **pquoimm** & **pofut**. The magnitude in differences is about 10<sup>-4</sup>. However this means that for one observation in the csur92 data set, **identif**=11636 for **anno**=1991 the resulting **duofut** variable has a value of `r a` in R , while this value is 0 for STATA.<br>
Observe that in generating **duofut** & **dimm** variables, variables used to compute them out from were rounded to 4 digits. It is the number of digits that offers the minimum number of differences in csur92 between data generated with R and STATA.<br><br>
<table style="width:50%" border="9" align="center"> <caption>Differences Between R & STATA Generated csur92 Data Set</caption> <tr> <td>identif</td><td>anno</td><td>R</td><td>STATA</td></tr> <tr> <td>11636</td><td>1991</td><td>duofut = 1</td><td>duofut = 0</td></tr></table><br>
<h6 align="left">2 - Creating intermediary data set csur95</h6>
The description of the methods of creation of the different variables described above for <u>csur92</u> data set holds for <u>csur95</u> data set, except in two minor differences. The first in the building of **razd** variable present in the data set above, and the second in the introduction of a new variable **dugr**.<br>
Here only observations current to 1995 (ranging 1991-1994) for firms in data set are selected and saved in csur95 data set. Additionally these firms should have a correct observation for number of employees the 3 years before (1991-1994) in order to be able to calculate labor growth.<br>
```{r, cache = TRUE}
csur95 <- subset(data,ind95==1 & dip94!="." & dip94>0)
#Size as Proxied by Total Sales;     
csur95$lsize <- ifelse(csur95$sales<= 0 , NA, log(csur95$sales))
```
The baseline definition of financial constraints in the 1995 survey is defined somehow different compared to 1992 survey. The construction of **razd** variable indicating financial constraint depends on variables *NONOTTEN* and *AVREBACC* in original data set. These two variables code yes or no answers (1 being yes and 0 No) to questions "Did in 1994 the firm wanted more credit, asked for it and was turned down by the bank ?" and "Was in 1994 the firm ready to pay higher loan rates or pledge more collateral to obtain more credit ?" respectively.<br>
If the first question was answered with a yes, then the firm is considered as financially constrained and variable **razd** will be equal to 1. If answers to both questions were missing then data on financial constraint is considered as missing. In any other case, firm is considered financially not constrained, giving a value of NA and 0 respectively.<br>
A copy of **razd** variable is made in variable **raz95d**.
```{r, cache = TRUE}
#Dummy Rationing Baseline def.;     
csur95$razd <- ifelse(csur95$nonotten == "."|is.na(csur95$nonotten) == TRUE, 0, ifelse(csur95$nonotten==1, 1, 0))
csur95$raz95d <- csur95$razd
a <- ifelse(is.na(csur95$nonotten)==TRUE, 0, ifelse(csur95$nonotten == 0, 20, 10))
b <- ifelse(is.na(csur95$avrebacc)==TRUE, 0, ifelse(csur95$avrebacc == 0, 2, 1))
c <- a + b
csur95$razd <- ifelse(c==0, NA, ifelse(c==10|c==11|c==12, 1, 0))
```
The M&A dummies are basically defined exactly as in above section.
```{r, cache = TRUE}
#Dummies M&A's;    
csur95$duacq <- ifelse(is.na(csur95$acqui),0,ifelse(csur95$acqui==1,1,0))
csur95$dusco<- ifelse(is.na(csur95$scorpo),0,ifelse(csur95$scorpo==1,1,0))
```
Here a new variable **dugr** is introduced based on *isgru* variable of original data set. The latter has a value of 1, if the firm in question is part of an industrial group, and 0 if not with possible NA values. However, **dugr** is constructed as equal to 1 if the firm is part of an industrial group, and 0 in any other situations.
```{r, cache = TRUE}
#Dummy Industrial Group   
csur95$durg <- ifelse(is.na(csur95$isgru),0,ifelse(csur95$isgru==1,1,0))
```
The following steps are defined exactly as in above section.
```{r, cache = TRUE}
#4 Pavitt Sectoral Dummies;
csur95$dupav1 <- ifelse(csur95$pav==1,1,0)
csur95$dupav2 <- ifelse(csur95$pav==2,1,0)
csur95$dupav3 <- ifelse(csur95$pav==3,1,0)
csur95$dupav4 <- ifelse(csur95$pav==4,1,0)
  
#Defining Balance-Sheet Variables
#Return on Assets
csur95$roa <- csur95$util/(csur95$aco + csur95$aim)
#Financial Expenses/Operating Profits
csur95$ofut <- ifelse(csur95$of/(csur95$of + csur95$utiln) == Inf, NA , csur95$of/(csur95$of + csur95$utiln))
#Share of Tangible Assets over Total Assets
csur95$quoimm <- csur95$imte/(csur95$aco + csur95$aim)
#Log of Sales
csur95$lsales <- ifelse(csur95$sales<= 0 , NA, log(csur95$sales))

#Generating Percentiles for the Dummies Low Coverage - Low Collateral
library(plyr)
common <- data.frame(tapply(csur95$ofut, csur95$anno, quantile, probs=.75, na.rm = TRUE))
a <- data.frame(rep(NA, times = 3))
b <- data.frame(rep(NA, times = (9 - nrow(common))))
names(common)[1] <- "common"
names(a)[1] <- "common"
names(b)[1] <- "common"
common <- data.frame(rbind(a, common, b))
csur95$pofut <- ifelse(csur95$anno=="1989-01-01",common[1,1],ifelse(csur95$anno=="1990-01-01",common[2,1],ifelse(csur95$anno=="1991-01-01",common[3,1],ifelse(csur95$anno=="1992-01-01",common[4,1],ifelse(csur95$anno=="1993-01-01",common[5,1],ifelse(csur95$anno=="1994-01-01",common[6,1],ifelse(csur95$anno=="1995-01-01",common[7,1],ifelse(csur95$anno=="1996-01-01",common[8,1],ifelse(csur95$anno=="1997-01-01",common[9,1],ifelse(csur95$anno=="1998-01-01",common[10,1],ifelse(csur95$anno=="1999-01-01",common[11,1],common[12,1])))))))))))

common <- data.frame(tapply(csur95$quoimm, csur95$anno, quantile, probs=.25, na.rm = TRUE))
a <- data.frame(rep(NA, times = 3))
b <- data.frame(rep(NA, times = (9 - nrow(common))))
names(common)[1] <- "common"
names(a)[1] <- "common"
names(b)[1] <- "common"
common <- data.frame(rbind(a, common, b))
csur95$duofut <- as.factor(ifelse(round(csur95$ofut, digits = 5) > round(csur95$pofut, digits = 5) & round(csur95$ofut, digits = 5) != ".",1,ifelse(round(csur95$ofut, digits = 5)==".",".",0)))

csur95$pquoimm <- ifelse(csur95$anno=="1989-01-01",common[1,1],ifelse(csur95$anno=="1990-01-01",common[2,1],ifelse(csur95$anno=="1991-01-01",common[3,1],ifelse(csur95$anno=="1992-01-01",common[4,1],ifelse(csur95$anno=="1993-01-01",common[5,1],ifelse(csur95$anno=="1994-01-01",common[6,1],ifelse(csur95$anno=="1995-01-01",common[7,1],ifelse(csur95$anno=="1996-01-01",common[8,1],ifelse(csur95$anno=="1997-01-01",common[9,1],ifelse(csur95$anno=="1998-01-01",common[10,1],ifelse(csur95$anno=="1999-01-01",common[11,1],common[12,1])))))))))))
csur95$dimm <- as.factor(ifelse(((round(csur95$quoimm, digits = 5) < round(csur95$pquoimm, digits = 5)) & (round(csur95$pquoimm, digits = 5) != ".")), 1, ifelse(round(csur95$quoimm, digits = 5)==".", ".", 0)))

csur95[grep("acqui",colnames(csur95))] <- NULL
csur95[grep("scorpo",colnames(csur95))] <- NULL
csur95[grep("isgru",colnames(csur95))] <- NULL
csur95[grep("^pav$",colnames(csur95))] <- NULL
  
csur95 <- csur95[order(csur95$identif),]
```
It is to be noticed here that generating quantiles with R and STATA gives slightly different values for **pquoimm** & **pofut**. The magnitude in differences is about 10<sup>-5</sup>. However this means that for one observation in the csur92 data set, **identif**=1839 for **anno**=1992 the resulting **duofut** variable has a value of 1 in R , while this value is 0 for STATA.<br>
Observe that in generating **duofut** & **dimm** variables, variables used to compute them out from were rounded to 5 digits. It is the number of digits that offers the minimum number of differences in csur95 between data generated with R and STATA.<br><br>
<table style="width:50%" border="9" align="center"> <caption>Differences Between R & STATA Generated csur95 Data Set</caption> <tr> <td>identif</td><td>anno</td><td>R</td><td>STATA</td></tr> <tr> <td>1839</td><td>1992</td><td>duofut = 1</td><td>duofut = 0</td></tr></table><br>
<h6 align="left">3 - Creating intermediary data set csur98</h6>
The creation of csur98 data set departs in three majors ways and in one major way from the construction of csur92 data set. First a minor adjustment in the selection of observation only contemporary to 1998.Here only observations current to 1998 (ranging 1995-1997) for firms in data set are selected and saved in csur98 data set. Additionally these firms should have a correct observation for number of employees the 3 years before (1995-1997) in order to be able to calculate labor growth. But authors seem to have added a condition that the age of the firm in 98 is not negative.<br>
Additionally a new variable **isgru** is introduced in the exact same manner as described for data set csur98.<br>
```{r, cache = TRUE}
csur98 <- subset(data,ind98 == 1 & dip97 != "." & dip97 > 0 & (eta98 >= 0 | is.na(eta98)))   
```
The baseline definition of financial constraints in the 1998 survey is defined somehow differently compared to both 1992 and 1995 surveys. The construction of financial constraint indicator **razd** is based on variables *desi*, *chie* and *paga* of the original data set. These variables represent code a yes or no question (1 being yes and 2 being no) to questions, "In the previous year the firm wanted more credit at the prevailing market conditions.", "In the previous year the firm asked for more credit but was turned down by the bank." and "In the previous year the firm would have accepted to pay a slightly higher loan rate." respectively.<br>
If answers to first question and second question both were positive, then the firm is considered as financially constrained and **razd** variable will be equal to 1, else if answers to all three questions were missing the firm is considered to be have no information on financial constraint having an NA value for **razd**, for all other situation the new variable will have a value of zero indicating no financial constraint of firm involved. A copy of this new variable is stored in variable **razd98d**.
```{r, cache = TRUE}
#Size as Proxied by Total Sales;
z <- ifelse(is.na(csur98$desi), 3, ifelse(csur98$desi == 1, 1, 2))
y <- ifelse(is.na(csur98$chie), 30, ifelse(csur98$chie == 1, 10, 20))
x <- ifelse(is.na(csur98$paga), 200, 100)
w <- z + y + x    

csur98$razd <- ifelse(w == 233, NA, ifelse(w == 111|w == 211, 1, 0))

csur98$raz98d <- csur98$razd

#Dummies M&A's;
csur98$duacq <- ifelse(is.na(csur98$acqui),0,ifelse(csur98$acqui==1,1,0))
csur98$dusco<- ifelse(is.na(csur98$scorpo),0,ifelse(csur98$scorpo==1,1,0))

#Dummy Industrial Group
csur98$isgru <- ifelse(is.na(csur98$isgru),0,ifelse(csur98$isgru==1,1,0))

#4 Pavitt Sectoral Dummies;
csur98$dupav1 <- ifelse(csur98$pav==1,1,0)
csur98$dupav2 <- ifelse(csur98$pav==2,1,0)
csur98$dupav3 <- ifelse(csur98$pav==3,1,0)
csur98$dupav4 <- ifelse(csur98$pav==4,1,0)

#Defining Balance-Sheet Variables
#Return on Assets
csur98$roa <- csur98$util/(csur98$aco + csur98$aim)
#Financial Expenses/Operating Profits
csur98$ofut <- ifelse(csur98$of/(csur98$of + csur98$utiln) == Inf, NA , csur98$of/(csur98$of + csur98$utiln))
#Share of Tangible Assets over Total Assets
csur98$quoimm <- csur98$imte/(csur98$aco + csur98$aim)
#Log of Sales
csur98$lsales <- ifelse(csur98$sales<= 0 , NA, log(csur98$sales))

#Generating Percentiles for the Dummies Low Coverage - Low Collateral
library(plyr)
common <- data.frame(tapply(csur98$ofut, csur98$anno, quantile, probs=.75, na.rm = TRUE))
a <- data.frame(rep(NA, times = 6))
b <- data.frame(rep(NA, times = (6 - nrow(common))))
names(common)[1] <- "common"
names(a)[1] <- "common"
names(b)[1] <- "common"
common <- data.frame(rbind(a, common, b))
csur98$pofut <- ifelse(csur98$anno=="1989-01-01",common[1,1],ifelse(csur98$anno=="1990-01-01",common[2,1],ifelse(csur98$anno=="1991-01-01",common[3,1],ifelse(csur98$anno=="1992-01-01",common[4,1],ifelse(csur98$anno=="1993-01-01",common[5,1],ifelse(csur98$anno=="1994-01-01",common[6,1],ifelse(csur98$anno=="1995-01-01",common[7,1],ifelse(csur98$anno=="1996-01-01",common[8,1],ifelse(csur98$anno=="1997-01-01",common[9,1],ifelse(csur98$anno=="1998-01-01",common[10,1],ifelse(csur98$anno=="1999-01-01",common[11,1],common[12,1])))))))))))

common <- data.frame(tapply(csur98$quoimm, csur98$anno, quantile, probs=.25, na.rm = TRUE))
a <- data.frame(rep(NA, times = 6))
b <- data.frame(rep(NA, times = (6 - nrow(common))))
names(common)[1] <- "common"
names(a)[1] <- "common"
names(b)[1] <- "common"
common <- data.frame(rbind(a, common, b))
csur98$duofut <- as.factor(ifelse(round(csur98$ofut, digits = 6) > round(csur98$pofut, digits = 6) & round(csur98$ofut, digits = 6) != ".",1,ifelse(round(csur98$ofut, digits = 6)==".",".",0)))

csur98$pquoimm <- ifelse(csur98$anno=="1989-01-01",common[1,1],ifelse(csur98$anno=="1990-01-01",common[2,1],ifelse(csur98$anno=="1991-01-01",common[3,1],ifelse(csur98$anno=="1992-01-01",common[4,1],ifelse(csur98$anno=="1993-01-01",common[5,1],ifelse(csur98$anno=="1994-01-01",common[6,1],ifelse(csur98$anno=="1995-01-01",common[7,1],ifelse(csur98$anno=="1996-01-01",common[8,1],ifelse(csur98$anno=="1997-01-01",common[9,1],ifelse(csur98$anno=="1998-01-01",common[10,1],ifelse(csur98$anno=="1999-01-01",common[11,1],common[12,1])))))))))))
csur98$dimm <- as.factor(ifelse(((round(csur98$quoimm, digits = 5) < round(csur98$pquoimm, digits = 5)) & (round(csur98$pquoimm, digits = 5) != ".")), 1, ifelse(round(csur98$quoimm, digits = 5)==".", ".", 0)))
```
A new variable **desi** is introduced here. This new variable is a dummy indicating if the firm desired more credit or not, based on *desi* variable in the original data set as described above. If the latter is equal to 1, **desi** variable will be equal to 1 indicating that the firm would have desired more credit the year in question. If all *desi*, *paga* and *chie* variables of the old data set had missing values the new **desi** variable will have an NA value. In any other case the value is equal to 0 indicating that firm did not need additional credit.<br>
A copy of this new variable **desi** is stored in new variable called **desi98**.
```{r, cache = TRUE}
#Dummy Desiring more Credit

a <- ifelse(is.na(csur98$desi), 3,ifelse(csur98$desi == 2, 2, 1))
b <- ifelse(is.na(csur98$chie), 20, 10)
c <- ifelse(is.na(csur98$paga), 200, 100)
d <- a + b + c
csur98$desi <- ifelse(d == 223, NA, ifelse(d == 111|d == 211|d == 121|d == 221, 1, 0))

csur98$desi98 <- csur98$desi

csur98[grep("acqui",colnames(csur98))] <- NULL
csur98[grep("scorpo",colnames(csur98))] <- NULL
csur98[grep("^pav$",colnames(csur98))] <- NULL

csur98 <- csur98[order(csur98$identif),]
```
It is to be noticed here that generating quantiles with R and STATA gives slightly different values for **pquoimm** & **pofut**. The magnitude in differences is about 10<sup>-5</sup>. However this means that for four observations in the csur98 data set the resulting **duofut**, and for one observation in the same data set the resulting **dimm** variables have differences for data sets generated using R and STATA.<br>
Observe that in generating **duofut** & **dimm** variables, variables used to compute them out from were rounded to 5 digits. It is the number of digits that offers the minimum number of differences in csur98 between data generated with R and STATA.<br><br>
<table style="width:50%" border="9" align="center"> <caption>Differences Between R & STATA Generated csur98 Data Set</caption> <tr> <td>identif</td><td>anno</td><td>R</td><td>STATA</td></tr> <tr> <td>1383790044</td><td>1997</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>1795940377</td><td>1995</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>7203080159</td><td>1996</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>327440278</td><td>1996</td><td>dimm = 1</td><td>dimm = 0</td></tr></table><br>

<h6 align="left">4 - Creating intermediary data set csur01</h6>
Here only observations current to 2001 (ranging 1998-200) for firms in data set are selected and saved in csur01 data set. Additionally these firms should have a correct observation for number of employees the 3 years before (1998-200) in order to be able to calculate labor growth. But authors seem to have added a condition that the age of the firm in 01 is not negative.<br>
As for the rest, the methods of creating the new variables are done in exactly the same manner as for <u>csur98</u>. Except that copies of new variable **razd** and **desi** for <u>csur01</u> data set are stored in variables **raz01d** and **desi01**.
```{r, cache = TRUE}
csur01 <- subset(data,ind01 == 1 & dip00 != "." & dip00 > 0 & (eta01 >= 0 | is.na(eta01)))
    
#Dummy Rationing Baseline def.
z <- ifelse(is.na(csur01$desi), 3, ifelse(csur01$desi == 1, 1, 2))
y <- ifelse(is.na(csur01$chie), 30, ifelse(csur01$chie == 1, 10, 20))
x <- ifelse(is.na(csur01$paga), 200, 100)
w <- z + y + x

csur01$razd <- ifelse(w == 233, NA, ifelse(w == 111|w == 211, 1, 0))

csur01$raz01d <- csur01$razd

#Dummies M&A's;
csur01$duacq <- ifelse(is.na(csur01$acqui),0,ifelse(csur01$acqui==1,1,0))
csur01$dusco<- ifelse(is.na(csur01$scorpo),0,ifelse(csur01$scorpo==1,1,0))

#Dummy Industrial Group
csur01$isgru <- ifelse(is.na(csur01$isgru),0,ifelse(csur01$isgru==1,1,0))

#4 Pavitt Sectoral Dummies;
csur01$dupav1 <- ifelse(csur01$pav==1,1,0)
csur01$dupav2 <- ifelse(csur01$pav==2,1,0)
csur01$dupav3 <- ifelse(csur01$pav==3,1,0)
csur01$dupav4 <- ifelse(csur01$pav==4,1,0)

#Defining Balance-Sheet Variables
#Return on Assets
csur01$roa <- csur01$util/(csur01$aco + csur01$aim)
#Financial Expenses/Operating Profits
csur01$ofut <- ifelse(csur01$of/(csur01$of + csur01$utiln) == Inf, NA , csur01$of/(csur01$of + csur01$utiln))
#Share of Tangible Assets over Total Assets
csur01$quoimm <- csur01$imte/(csur01$aco + csur01$aim)
#Log of Sales
csur01$lsales <- ifelse(csur01$sales<= 0 , NA, log(csur01$sales))

#Generating Percentiles for the Dummies Low Coverage - Low Collateral
library(plyr)
common <- data.frame(tapply(csur01$ofut, csur01$anno, quantile, probs=.75, na.rm = TRUE))
a <- data.frame(rep(NA, times = 9))
b <- data.frame(rep(NA, times = (3 - nrow(common))))
names(common)[1] <- "common"
names(a)[1] <- "common"
names(b)[1] <- "common"
common <- data.frame(rbind(a, common, b))
csur01$pofut <- ifelse(csur01$anno=="1989-01-01",common[1,1],ifelse(csur01$anno=="1990-01-01",common[2,1],ifelse(csur01$anno=="1991-01-01",common[3,1],ifelse(csur01$anno=="1992-01-01",common[4,1],ifelse(csur01$anno=="1993-01-01",common[5,1],ifelse(csur01$anno=="1994-01-01",common[6,1],ifelse(csur01$anno=="1995-01-01",common[7,1],ifelse(csur01$anno=="1996-01-01",common[8,1],ifelse(csur01$anno=="1997-01-01",common[9,1],ifelse(csur01$anno=="1998-01-01",common[10,1],ifelse(csur01$anno=="1999-01-01",common[11,1],common[12,1])))))))))))

common <- data.frame(tapply(csur01$quoimm, csur01$anno, quantile, probs=.25, na.rm = TRUE))
a <- data.frame(rep(NA, times = 9))
b <- data.frame(rep(NA, times = (3 - nrow(common))))
names(common)[1] <- "common"
names(a)[1] <- "common"
names(b)[1] <- "common"
common <- data.frame(rbind(a, common, b))
csur01$duofut <- as.factor(ifelse(round(csur01$ofut, digits = 6) > round(csur01$pofut, digits = 6) & round(csur01$ofut, digits = 6) != ".",1,ifelse(round(csur01$ofut, digits = 6)==".",".",0)))

csur01$pquoimm <- ifelse(csur01$anno=="1989-01-01",common[1,1],ifelse(csur01$anno=="1990-01-01",common[2,1],ifelse(csur01$anno=="1991-01-01",common[3,1],ifelse(csur01$anno=="1992-01-01",common[4,1],ifelse(csur01$anno=="1993-01-01",common[5,1],ifelse(csur01$anno=="1994-01-01",common[6,1],ifelse(csur01$anno=="1995-01-01",common[7,1],ifelse(csur01$anno=="1996-01-01",common[8,1],ifelse(csur01$anno=="1997-01-01",common[9,1],ifelse(csur01$anno=="1998-01-01",common[10,1],ifelse(csur01$anno=="1999-01-01",common[11,1],common[12,1])))))))))))
csur01$dimm <- as.factor(ifelse(((round(csur01$quoimm, digits = 5) < round(csur01$pquoimm, digits = 5)) & (round(csur01$pquoimm, digits = 5) != ".")), 1, ifelse(round(csur01$quoimm, digits = 5)==".", ".", 0)))

a <- ifelse(is.na(csur01$desi), 3,ifelse(csur01$desi == 2, 2, 1))
b <- ifelse(is.na(csur01$chie), 20, 10)
c <- ifelse(is.na(csur01$paga), 200, 100)
d <- a + b + c
csur01$desi <- ifelse(d == 223, NA, ifelse(d == 111|d == 211|d == 121|d == 221, 1, 0))

csur01$desi01 <- csur01$desi

csur01[grep("acqui",colnames(csur01))] <- NULL
csur01[grep("scorpo",colnames(csur01))] <- NULL
csur01[grep("^pav$",colnames(csur01))] <- NULL

csur01 <- csur01[order(csur01$identif),]
```
It is to be noticed here that generating quantiles with R and STATA gives slightly different values for **pquoimm** & **pofut**. The magnitude in differences is about 10<sup>-5</sup>. However this means that for two observations in the csur01 data set the resulting **duofut**, and for three observations in the same data set the resulting **dimm** variables have differences for data sets generated using R and STATA.<br>
Observe that in generating **duofut** & **dimm** variables, variables used to compute them out from were rounded to 5 digits. It is the number of digits that offers the minimum number of differences in csur98 between data generated with R and STATA.<br><br>
<table style="width:50%" border="9" align="center"> <caption>Differences Between R & STATA Generated csur01 Data Set</caption> <tr> <td>identif</td><td>anno</td><td>R</td><td>STATA</td></tr> <tr> <td>59520065</td><td>1999</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>1427530075</td><td>2000</td><td>duofut = 1</td><td>duofut = 0</td></tr><tr> <td>1514750982</td><td>1999</td><td>dimm = 1</td><td>dimm = 0</td></tr><tr> <td>1588800986</td><td>2000</td><td>dimm = 1</td><td>dimm = 0</td></tr><tr> <td>2665140833</td><td>1998</td><td>dimm = 1</td><td>dimm = 0</td></tr></table><br>

<h4 align="left"> B - 1992 - 1995 and 1998 - 2001 surveys data sets & Main Data Sets Corrections</h4>
The 1992 - 1995 and 1998 - 2001 surveys data sets, eliminate both firms with errors in the age field of firms, and fills them if age is missing. However the latter can be done only for firms present on both years of each data set. They also create a dummy for persistently constrained firms.<br> Using these additional information, one can complete the main data sets created in section A above.
<h6 align="left">1 - 1992 - 1995 survey data set.</h6>
A new data set <u>csuro92</u> is created out of <u>csur92</u> data set, by taking only variables **raz92d** as defined in section A1, variables **eta92** and **identif**, present in original data set and representing the age of the firm in 1992 and a unique firm identifier respectively but exclusively for observations made on 1991.
```{r, cache = TRUE}
suppressMessages(library(lubridate))
csuro92 <- subset(csur92, year(csur92$anno) == 1991)
csuro92 <- data.frame(csuro92$identif, csuro92$eta92, csuro92$raz92d)
colnames(csuro92) <- c("identif", "eta92", "raz92d")
```
A new data set <u>csuro95</u> is created out of <u>csur95</u> data set, by taking only variables **raz95d** as defined in section A2, variables **eta95** and **identif**, present in original data set and representing the age of the firm in 1995 and a unique firm identifier respectively but exclusively for observations made on 1994.
```{r, cache = TRUE}
suppressMessages(library(lubridate))   
csuro95 <- subset(csur95, as.numeric(year(csur95$anno)) == 1994)
csuro95 <- data.frame(csuro95$identif, csuro95$eta95, csuro95$raz95d)
colnames(csuro95) <- c("identif", "eta95", "raz95d")

merge1 <- merge(csuro92, csuro95, by=c("identif"), all=TRUE)

ind1 <- ifelse(is.na(merge1$eta92) & is.na(merge1$raz92d), 1, 2)
ind2 <- ifelse(is.na(merge1$eta95) & is.na(merge1$raz95d), 10, 20)
ind3 <- ind1 + ind2
merge1$merge <- as.integer(ifelse(ind3 == 12, 1, ifelse(ind3 == 21, 2, ifelse(ind3 == 11, NA, 3))))

merge1 <- merge1[order(merge1$identif), ]
```
In the end, the two new data sets <u>csuro92</u> and <u>csuro95</u> are merged by **identif**, filling all very probable empty observations by an NA. The obtained data set is ordered by identif, and named <u>merge1</u>.<br>
What is done in the code chunk below is to compute the missing age data of a firm present in both surveys, but whose age in one survey is missing. A firm present in both 95 and 92 survey whose age in 95 is there, but for whom age in 92 is missing or illogical, age in 92 is set equal to age in 95 - 3.<br>
Similarly, a firm present in both 95 and 92 survey whose age in 92 is there, but for whom age in 95 is missing or illogical, age in 95 is set equal to age in 92 + 3. In any other case original observations of age from data sets <u>csuro92</u> and <u>csuro95</u> are kept. These new ages are stored in variables called **eta92c** and **eta95c**. Original **eta92** and **eta95** age variables are deleted.<br>
```{r, cache = TRUE}
#uses age from one survey to compute age.survey
merge1$eta92c <- ifelse((is.na(merge1$eta92)|merge1$eta92<0) & (!is.na(merge1$eta95) ) & merge1$merge == 3, merge1$eta95 - 3, merge1$eta92)
merge1$eta95c <- ifelse((is.na(merge1$eta95)|merge1$eta95<0) & (!is.na(merge1$eta92) ) & merge1$merge == 3, merge1$eta92 + 3, merge1$eta95)    

merge1[grep("^eta92$",colnames(merge1))] <- NULL
merge1[grep("^eta95$",colnames(merge1))] <- NULL
merge1[grep("^merge$",colnames(merge1))] <- NULL
```
What is done in the next code chunk is to create a **deta** variable that stores the differences in age between 1995 and 1992 as proxied by **eta95c** and **eta92c** as seen above. Then observations with large error in age field, or for deta superior to 5 or inferior to 1, observation is deleted. Next small differences in age field, for deta = 2 and = 4 the difference is squared to 3, by replacing value of **eta95c** by value of **eta92c** plus 3.
```{r, cache = TRUE}
#Drops firms in the balanced sample with large errors in the age field
merge1$deta <- merge1$eta95c - merge1$eta92c
merge1 <- subset(merge1,(merge1$deta > 1 |is.na(merge1$deta)) & (merge1$deta < 5 |is.na(merge1$deta)))
#forces small differences in age to square to 3
merge1$eta95c <- ifelse(is.na(merge1$deta), merge1$eta95c,ifelse(merge1$deta == 2 | merge1$deta == 4, merge1$eta92c + 3, merge1$eta95c))
```
In the last code chunk of this part, a dummy variable named **persist** is created as an indicator of persistently constrained firms. If the firm was financially constrained in 92 (**raz92d** equals 1) and in 95 (**raz95d** equals 1) then the firm is considered persistently financially constrained. Then **perist** equals 1, or 0 in any other case. Only variables **indentif**, **eta92c**, **eta95c** and **persist** are kept in the data set that is also ordered by **identif** variable.<br>
The end data set is then stored under the name <u>temp9295</u>.
```{r, cache = TRUE}
merge1$russia <- as.numeric(as.character(merge1$raz92d)) + as.numeric(as.character(merge1$raz95d))
merge1$persist <- as.factor(ifelse( is.na(merge1$russia), 0, ifelse(merge1$russia == 2, 1, 0)))
temp9295 <- data.frame(merge1$identif, merge1$eta92c, merge1$eta95c, merge1$persist)
colnames(temp9295) <- c("identif", "eta92c", "eta95c", "persist")
temp9295 <- temp9295 [order(temp9295$identif),]
```
In generating data set <u>temp9295</u> no differences were observed between data set generated with STATA and one generated with R.
<h6 align="left">2 - 1998 - 2001 survey data set.</h6>
<br>
<h6><sup>1</sup>Angelini, Paolo, and Andrea Generale. 2008. "On the Evolution of Firm Size Distributions." American Economic Review, 98(1): 426-38.</h6>
